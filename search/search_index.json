{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Documentation:   Rust   -   Python   |   Repository:   GitHub </p> Kand: A Modern, High-Performance Technical Analysis Library <p>\u26a0\ufe0f Development Status: This project is under active development. APIs may change, and some features might not be fully implemented or tested yet. Contributions and feedback are welcome!</p> <p> </p> <p> EMA calculation performance comparison across different implementations. </p>"},{"location":"#why-kand","title":"Why Kand?","text":"<p><code>Kand</code> is engineered as a modern replacement for <code>TA-Lib</code>, addressing its core limitations\u2014such as single-threaded execution, Python GIL constraints, memory overhead, and inefficient real-time processing\u2014while preserving its strengths in comprehensive indicator support and ease of integration. Built in Rust, <code>Kand</code> delivers superior performance, safety, and flexibility for quantitative trading, data science, and financial analysis.</p> <ul> <li> <p>\u26a1 Superior Performance with Memory Safety   Leveraging Rust's efficiency, <code>Kand</code> achieves speeds rivaling or exceeding <code>TA-Lib</code>'s peak performance, but with built-in memory safety that eliminates common vulnerabilities and reduces overhead in <code>TA-Lib</code>'s C-based implementation.</p> </li> <li> <p>\ud83d\udd13 True Multithreading Capabilities   Unlike <code>TA-Lib</code>, which is hindered by Python's GIL and single-threaded design, <code>Kand</code> enables seamless parallel processing across multiple cores, unlocking significant gains in multi-threaded environments for large-scale computations.</p> </li> <li> <p>\u2699\ufe0f Efficient Real-Time Incremental Updates <code>Kand</code> introduces O(1) complexity for incremental calculations, ideal for streaming data and real-time applications\u2014overcoming <code>TA-Lib</code>'s reliance on batch processing, which introduces latency and inefficiency in dynamic scenarios.</p> </li> <li> <p>\ud83d\ude80 Zero-Copy NumPy Integration   With native, zero-copy data sharing via Rust-NumPy bindings, <code>Kand</code> ensures lossless, high-speed data flow between Python and Rust, addressing <code>TA-Lib</code>'s memory copying overhead and enabling ultra-low latency (~7ns) operations.</p> </li> <li> <p>\ud83d\udcca Expanded Indicator Suite   Kand supports a wide array of standard indicators (e.g., EMA, RSI, MACD) like <code>TA-Lib</code>, while pioneering advanced ones such as Vegas, VWAP, and Supertrend, extending analytical capabilities beyond <code>TA-Lib</code>'s traditional scope.</p> </li> <li> <p>\ud83d\udce6 Streamlined Installation and Lightweight Design   Install with a single <code>pip install kand</code> command, featuring precompiled wheels and no complex C dependencies\u2014solving <code>TA-Lib</code>'s notoriously cumbersome setup and reducing package bloat for effortless deployment.</p> </li> <li> <p>\ud83d\udcbb Broad Cross-Platform Compatibility   Seamlessly runs on macOS, Linux, and Windows, with additional support for JavaScript/TypeScript via <code>WebAssembly</code>, providing greater universality than <code>TA-Lib</code>'s platform-specific challenges.</p> </li> </ul> <p>If you truly understand <code>TA-Lib</code>'s limitations, you'll appreciate Kand's innovations. <code>Kand</code> isn't just about fixing what's broken\u2014it's about enabling what's possible. Dive deeper at why <code>kand</code>.</p>"},{"location":"#python-api","title":"Python API","text":"<p>The Python interface of <code>kand</code> leverages PyO3 for ultra-low latency bindings (~7ns overhead) to the Rust core, seamlessly integrating with NumPy for zero-copy operations and true thread-safe calculations. Below are examples for batch and incremental usage.</p> <pre><code>import numpy as np\nfrom kand import ema\n\n# Batch EMA computation with zero-copy NumPy integration\nprices = np.array([10.0, 11.0, 12.0, 13.0, 14.0], dtype=np.float64)\nema_values = ema(prices, period=3)\n\n# Incremental EMA update for streaming data\nprev_ema = 13.5\nnew_price = 15.0\nnew_ema = ema_inc(new_price, prev_ema, period=3)\n</code></pre> <p>Key Features:</p> <ul> <li>Zero-Copy: Operates directly on NumPy arrays, avoiding memory duplication.</li> <li>GIL-Free: Rust backend releases the Python GIL, enabling parallel execution.</li> <li>Incremental Updates: O(1) complexity for real-time applications.</li> </ul>"},{"location":"#rust-api","title":"Rust API","text":"<p>The Rust interface in <code>kand</code> provides a high-performance, type-safe implementation of EMA with flexible parameter control. It supports both Vec and ndarray inputs for batch and incremental calculations, as shown below.</p> <pre><code>use kand::ohlcv::ema;\nuse ndarray::Array1;\n\n// Batch EMA calculation over a price series\nlet prices = vec![10.0, 11.0, 12.0, 13.0, 14.0];\nlet mut ema_values = vec![0.0; prices.len()];\nema::ema(&amp;prices, 3, None, &amp;mut ema_values)?;\n\n// Batch EMA with ndarray for scientific workflows\nlet prices = Array1::from_vec(vec![10.0, 11.0, 12.0, 13.0, 14.0]);\nlet mut ema_values = Array1::zeros(prices.len());\nema::ema(&amp;prices, 3, None, &amp;mut ema_values)?;\n\n// Constant-time incremental EMA update\nlet prev_ema = 13.5;\nlet new_price = 15.0;\nlet new_ema = ema::ema_inc(new_price, prev_ema, 3, None)?;\n</code></pre> <p>Key Features:</p> <ul> <li>Memory Efficiency: Leverages mutable buffers (<code>&amp;mut Vec&lt;f64&gt;</code> or <code>&amp;mut Array1&lt;f64&gt;</code>) to store results, slashing memory allocations.</li> <li>Error Handling: Returns <code>Result&lt;(), KandError&gt;</code> or <code>Result&lt;f64, KandError&gt;</code> for reliable failure detection (e.g., invalid period, NaN inputs).</li> <li>Incremental Design: O(1) updates tailored for real-time systems.</li> </ul>"},{"location":"#setup","title":"Setup","text":""},{"location":"#python","title":"Python","text":"<p>Get started with Kand in one command - no extra configuration needed:</p> <pre><code>pip install kand\n</code></pre>"},{"location":"#rust","title":"Rust","text":"<p>You can take latest release from <code>crates.io</code>, or if you want to use the latest features / performance improvements point to the <code>main</code> branch of this repo.</p> <pre><code>[dependencies]\nkand = { git = \"https://github.com/kand-ta/kand\", rev = \"&lt;optional git tag&gt;\" }\n</code></pre> <p>Recommend Rust version <code>&gt;=1.80</code>.</p>"},{"location":"#functions-list","title":"Functions List","text":""},{"location":"#ohlcv-based","title":"OHLCV Based","text":"<ul> <li> AD - Chaikin A/D Line</li> <li> ADOSC - Chaikin A/D Oscillator</li> <li> ADR - Average Daily Range</li> <li> ADX - Average Directional Movement Index</li> <li> ADXR - Average Directional Movement Index Rating</li> <li> APO - Absolute Price Oscillator</li> <li> AROON - Aroon</li> <li> AROONOSC - Aroon Oscillator</li> <li> ATR - Average True Range</li> <li> BBANDS - Bollinger Bands</li> <li> BOP - Balance Of Power</li> <li> CCI - Commodity Channel Index</li> <li> CDL_DOJI - Doji</li> <li> CDL_DRAGONFLY_DOJI - Dragonfly Doji</li> <li> CDL_GRAVESTONE_DOJI - Gravestone Doji</li> <li> CDL_HAMMER - Hammer</li> <li> CDL_INVERTED_HAMMER - Inverted Hammer</li> <li> CDL_LONG_LOWER_SHADOW - Long Lower Shadow</li> <li> CDL_LONG_UPPER_SHADOW - Long Upper Shadow</li> <li> CDL_MARUBOZU - Marubozu</li> <li> CMO - Chande Momentum Oscillator</li> <li> DEMA - Double Exponential Moving Average</li> <li> DX - Directional Movement Index</li> <li> EMA - Exponential Moving Average</li> <li> ECL - Expanded Camarilla Levels [Untested]</li> <li> HA - Heikin Ashi Chart</li> <li> KAMA - Kaufman Adaptive Moving Average</li> <li> MACD - Moving Average Convergence/Divergence [Unstable]</li> <li> MACDEXT - MACD with controllable MA type</li> <li> MAMA - MESA Adaptive Moving Average</li> <li> MEDPRICE - Median Price</li> <li> MFI - Money Flow Index [No Incremental]</li> <li> MIDPOINT - MidPoint over period</li> <li> MIDPRICE - Midpoint Price over period</li> <li> MINUS_DI - Minus Directional Indicator</li> <li> MINUS_DM - Minus Directional Movement</li> <li> MOM - Momentum</li> <li> NATR - Normalized Average True Range</li> <li> OBV - On Balance Volume</li> <li> PLUS_DI - Plus Directional Indicator</li> <li> PLUS_DM - Plus Directional Movement</li> <li> PPO - Percentage Price Oscillator</li> <li> RENKO - Renko Chart</li> <li> RMA - Rolling Moving Average</li> <li> ROC - Rate of change : ((price/prevPrice)-1)*100</li> <li> ROCP - Rate of change Percentage: (price-prevPrice)/prevPrice</li> <li> ROCR - Rate of change ratio: (price/prevPrice)</li> <li> ROCR100 - Rate of change ratio 100 scale: (price/prevPrice)*100</li> <li> RSI - Relative Strength Index</li> <li> SAR - Parabolic SAR</li> <li> SAREXT - Parabolic SAR - Extended</li> <li> SMA - Simple Moving Average</li> <li> STOCH - Stochastic [No Incremental]</li> <li> STOCHF - Stochastic Fast</li> <li> STOCHRSI - Stochastic Relative Strength Index</li> <li> SUPERTREND - Super Trend Indicator</li> <li> T3 - Triple Exponential Moving Average (T3)</li> <li> TEMA - Triple Exponential Moving Average</li> <li> TRANGE - True Range</li> <li> TRIMA - Triangular Moving Average</li> <li> TRIX - 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA</li> <li> TSF - Time Series Forecast</li> <li> TYPPRICE - Typical Price</li> <li> ULTOSC - Ultimate Oscillator</li> <li> VEGAS - VEGAS Channel and Trend Boundary EMAs [Untested]</li> <li> VWAP - Volume Weighted Average Price</li> <li> WCLPRICE - Weighted Close Price</li> <li> WILLR - Williams' %R</li> <li> WMA - Weighted Moving Average</li> </ul>"},{"location":"#statistical-analysis","title":"Statistical Analysis","text":"<ul> <li> ALPHA - Alpha: Measures excess returns over market</li> <li> BETA - Beta: Measures sensitivity to market volatility</li> <li> CALMAR - Calmar Ratio: Annual return to maximum drawdown ratio</li> <li> CORREL - Pearson's Correlation Coefficient</li> <li> DRAWDOWN - Maximum Drawdown: Maximum potential loss</li> <li> KELLY - Kelly Criterion: Optimal position sizing</li> <li> MAX - Highest value over a specified period</li> <li> MIN - Lowest value over a specified period</li> <li> SHARPE - Sharpe Ratio: Risk-adjusted return measure</li> <li> SORTINO - Sortino Ratio: Downside risk-adjusted returns</li> <li> STDDEV - Standard Deviation</li> <li> SUM - Summation</li> <li> VAR - Variance</li> <li> WINRATE - Win Rate: Strategy success probability</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We are passionate about supporting contributors of all levels of experience and would love to see you get involved in the project. See the contributing guide to get started.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under either of the following licenses, at your option:</p> <ul> <li>Apache License, Version 2.0, (LICENSE-APACHE or https://www.apache.org/licenses/LICENSE-2.0)</li> <li>MIT license (LICENSE-MIT or https://opensource.org/licenses/MIT)</li> </ul> <p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in kand by you, as defined in the Apache-2.0 license, shall be dually licensed as above, without any additional terms or conditions.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This project is provided \"as is\" without any warranties or guarantees of any kind, express or implied, including but not limited to warranties of merchantability, fitness for a particular purpose, accuracy, or non-infringement. The authors and contributors of this project are not liable for any damages, losses, or liabilities resulting from the use of this project, including but not limited to financial losses, investment decisions, or trading outcomes.</p> <p>Trading or investing in financial instruments involves high risks, including the potential loss of some or all of your investment amount, and may not be suitable for all users. Before using this project for any financial purposes, you should carefully consider your investment objectives, level of experience, and risk tolerance, and seek independent professional advice if needed.</p> <p>The information, data, and calculations provided by this project are for informational purposes only and do not constitute financial, investment, or trading advice, recommendations, or solicitations to buy or sell any securities or assets. We do not guarantee the accuracy, completeness, or timeliness of any output, and users assume all risks and liabilities associated with its use.</p>"},{"location":"about/","title":"About Kand","text":""},{"location":"about/#the-motivation","title":"The Motivation","text":"<p>TALib has long been a cornerstone for financial indicator calculations, valued for its comprehensive feature set. However, as modern workflows demand higher performance and flexibility, its limitations have become apparent:</p> <ul> <li>Performance Bottlenecks: TALib\u2019s C-based core, while fast, is constrained by Python\u2019s Global Interpreter Lock (GIL), limiting multi-threaded potential in today\u2019s multi-core world. This issue has been a persistent challenge, as noted in discussions around the Python bindings.</li> <li>Complex Setup: Installing TALib often involves wrangling C library dependencies, a hurdle for users seeking quick deployment. The fact that installation issues dominate their GitHub issues speaks volumes about this challenge.</li> <li>Batch-Only Design: TALib focuses on full-batch computations, lacking efficient incremental updates needed for real-time systems. While its Python bindings offer a stream feature for incremental calculations, it still relies on batch processing underneath, resulting in slower performance. Even attempts to address parallelism in the native C library highlight its multi-threading constraints.</li> </ul> <p>These pain points inspired us to rethink how financial tools should work in a modern, high-performance context.</p>"},{"location":"about/#why-we-built-kand","title":"Why We Built Kand","text":"<p><code>kand</code> was created to address TALib\u2019s shortcomings and deliver a next-generation solution for financial developers. Leveraging Rust\u2019s speed and safety, we set out to build a library that\u2019s not just an alternative, but a leap forward:</p> <ul> <li>Elite Performance: Written in Rust, <code>kand</code> matches or exceeds TALib\u2019s speed while adding GIL-free multi-threading for true parallelism.</li> <li>Seamless Integration: Powered by <code>rust-numpy</code>, <code>kand</code> shares array memory addresses directly between Python and Rust, enabling true zero-copy data access without any overhead in cross-language operations.</li> <li>Real-Time Ready: True O(1) complexity with near-zero overhead\u2014each update is just a pure variable computation without loops or batching, making it ideal for real-time streaming data processing.</li> <li>Frictionless Setup: A single <code>pip install</code> command replaces TALib\u2019s cumbersome C setup, with precompiled wheels for all major platforms.</li> <li>Cross-Platform Power: Runs effortlessly on Linux, macOS, and Windows\u2014musl Linux included.</li> </ul>"},{"location":"about/#our-vision","title":"Our Vision","text":"<p><code>kand</code> isn\u2019t just about fixing what\u2019s broken\u2014it\u2019s about enabling what\u2019s possible. Whether you\u2019re a quant trader, data scientist, or developer, we aim to provide a tool that\u2019s fast, reliable, and effortless to use, so you can focus on building, not battling your tools.</p> <p>To see <code>kand</code> in action, check out our Installation Guide or dive into the API Documentation.</p>"},{"location":"advance/","title":"Advanced Configuration Guide","text":"<p>This guide explains how to customize <code>kand</code> for numerical precision, optimization, and cross-platform use. Custom configurations require building from source with <code>maturin</code>, as the default <code>pip install kand</code> provides a pre-built package with fixed settings (<code>f64</code>, <code>i64</code>, <code>check</code>).</p>"},{"location":"advance/#customization-options","title":"Customization Options","text":""},{"location":"advance/#numerical-precision","title":"Numerical Precision","text":"<p>Choose the floating-point precision for your needs:</p> <ul> <li><code>f32</code> (32-bit): Lower memory usage, great for large datasets or constrained systems.</li> <li><code>f64</code> (64-bit): Default, higher precision for complex calculations.</li> </ul> Precision Memory Usage Precision Use Case <code>f32</code> Low Lower Embedded systems, big data <code>f64</code> Medium Higher Scientific computing"},{"location":"advance/#integer-types","title":"Integer Types","text":"<p>Select the integer type for indexing:</p> <ul> <li><code>i32</code> (32-bit): Memory-efficient, suits smaller applications.</li> <li><code>i64</code> (64-bit): Default, handles larger datasets.</li> </ul> Type Description Best For <code>i32</code> 32-bit integers Small-scale applications <code>i64</code> 64-bit integers Large datasets"},{"location":"advance/#validation-levels","title":"Validation Levels","text":"<p>Adjust validation for safety vs. performance:</p> <ul> <li><code>check</code>: Basic validation, ideal for production.</li> <li><code>deep-check</code>: Detailed checks, best for debugging.</li> <li>None: No validation, fastest but risky.</li> </ul> Level Safety Performance Use Case <code>check</code> High Medium Production <code>deep-check</code> Highest Slowest Debugging None Low Fastest Tested environments <p>Performance vs. Safety</p> <p>Skipping validation boosts speed but may cause issues with invalid inputs. Use cautiously.</p>"},{"location":"advance/#building-from-source","title":"Building from Source","text":"<p>Customizing <code>kand</code> requires a local build with <code>maturin</code>.</p>"},{"location":"advance/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.8+</li> <li>Rust: 1.80+</li> <li>maturin: <code>pip install maturin</code></li> </ul>"},{"location":"advance/#build-steps","title":"Build Steps","text":"<ol> <li> <p>Clone the Repository:    <pre><code>git clone https://github.com/rust-ta/kand.git\ncd kand\n</code></pre></p> </li> <li> <p>Build with Custom Features:     For development (editable install):     <pre><code>maturin develop --features f32,i64,check\n</code></pre></p> </li> </ol> <p>High-Performance Build Example</p> <p>Use <code>--release</code> for an optimized build: <pre><code>maturin build --release --features f64,i64,check\n</code></pre></p>"},{"location":"advance/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Feature Not Working: Ensure <code>--features</code> matches your desired configuration (e.g., <code>f32,i64,check</code>).</li> <li>Build Fails: Check Rust/Python versions or run <code>cargo build</code> to debug.</li> <li>Help: Visit GitHub Discussions.</li> </ul>"},{"location":"advance/#performance-trade-offs","title":"Performance Trade-offs","text":"Configuration Memory Speed Precision <code>f32, i32, no checks</code> Lowest Fastest Lowest <code>f32, i64, check</code> Low Fast Low <code>f64, i64, check</code> Medium Medium High <code>f64, i64, deep-check</code> High Slowest Highest <p>See the Performance Guide for benchmarks.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#kand","title":"<code>kand</code>","text":""},{"location":"api/#kand.ad","title":"<code>ad(high, low, close, volume)</code>  <code>builtin</code>","text":"<p>Computes the Accumulation/Distribution (A/D) indicator over NumPy arrays.</p> <p>The A/D indicator measures the cumulative flow of money into and out of a security by combining price and volume data. It helps identify whether buying or selling pressure is dominant.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>volume</code> <p>Volume data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the A/D values. The array has the same length as the inputs.</p> <p>Examples:     <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 13.0])\n&gt;&gt;&gt; volume = np.array([100.0, 150.0, 200.0])\n&gt;&gt;&gt; result = kand.ad(high, low, close, volume)\n&gt;&gt;&gt; print(result)\n[-50.0, 25.0, 125.0]\n</code></pre></p>"},{"location":"api/#kand.ad_inc","title":"<code>ad_inc(high, low, close, volume, prev_ad)</code>  <code>builtin</code>","text":"<p>Computes the latest Accumulation/Distribution (A/D) value incrementally.</p> <p>This function calculates only the latest A/D value using the previous A/D value, avoiding recalculation of the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Latest high price.</p> required <code>low</code> <p>Latest low price.</p> required <code>close</code> <p>Latest closing price.</p> required <code>volume</code> <p>Latest volume.</p> required <code>prev_ad</code> <p>Previous A/D value.</p> required <p>Returns:</p> Type Description <p>The latest A/D value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = 15.0\n&gt;&gt;&gt; low = 11.0\n&gt;&gt;&gt; close = 13.0\n&gt;&gt;&gt; volume = 200.0\n&gt;&gt;&gt; prev_ad = 25.0\n&gt;&gt;&gt; result = kand.ad_inc(high, low, close, volume, prev_ad)\n&gt;&gt;&gt; print(result)\n125.0\n</code></pre>"},{"location":"api/#kand.adosc","title":"<code>adosc(high, low, close, volume, fast_period, slow_period)</code>  <code>builtin</code>","text":"<p>Calculate Accumulation/Distribution Oscillator (A/D Oscillator or ADOSC)</p> <p>The A/D Oscillator is a momentum indicator that measures the difference between a fast and slow EMA of the Accumulation/Distribution Line. It helps identify trend strength and potential reversals.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>volume</code> <p>Volume as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>fast_period</code> <p>Fast period for A/D Oscillator calculation.</p> required <code>slow_period</code> <p>Slow period for A/D Oscillator calculation.</p> required <p>Returns:</p> Type Description <p>A tuple of 4 1-D NumPy arrays containing:</p> <ul> <li>ADOSC values</li> </ul> <ul> <li>A/D Line values</li> </ul> <ul> <li>Fast EMA values</li> </ul> <ul> <li>Slow EMA values</li> </ul> <p>Each array has the same length as the input, with the first <code>slow_period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 11.0, 12.0, 11.5, 10.5])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 10.0, 9.5, 8.5])\n&gt;&gt;&gt; close = np.array([9.0, 10.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; volume = np.array([100.0, 150.0, 200.0, 150.0, 100.0])\n&gt;&gt;&gt; adosc, ad, fast_ema, slow_ema = kand.adosc(high, low, close, volume, 3, 5)\n</code></pre>"},{"location":"api/#kand.adosc_inc","title":"<code>adosc_inc(high, low, close, volume, prev_ad, prev_fast_ema, prev_slow_ema, fast_period, slow_period)</code>  <code>builtin</code>","text":"<p>Calculate latest A/D Oscillator value incrementally</p> <p>Provides optimized calculation of the latest ADOSC value when new data arrives, without recalculating the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Latest high price.</p> required <code>low</code> <p>Latest low price.</p> required <code>close</code> <p>Latest closing price.</p> required <code>volume</code> <p>Latest volume.</p> required <code>prev_ad</code> <p>Previous A/D value.</p> required <code>prev_fast_ema</code> <p>Previous fast EMA value.</p> required <code>prev_slow_ema</code> <p>Previous slow EMA value.</p> required <code>fast_period</code> <p>Fast EMA period.</p> required <code>slow_period</code> <p>Slow EMA period.</p> required <p>Returns:</p> Type Description <p>A tuple containing (ADOSC, AD, Fast EMA, Slow EMA) values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; adosc, ad, fast_ema, slow_ema = kand.adosc_inc(\n...     10.5,  # high\n...     9.5,   # low\n...     10.0,  # close\n...     150.0, # volume\n...     100.0, # prev_ad\n...     95.0,  # prev_fast_ema\n...     90.0,  # prev_slow_ema\n...     3,     # fast_period\n...     10,    # slow_period\n... )\n</code></pre>"},{"location":"api/#kand.adx","title":"<code>adx(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Calculate Average Directional Index (ADX) for a NumPy array</p> <p>The ADX (Average Directional Index) measures the strength of a trend, regardless of whether it's up or down. Values range from 0 to 100, with higher values indicating stronger trends.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for ADX calculation (typically 14). Must be positive.</p> required <p>Returns:</p> Type Description <p>A tuple of four 1-D NumPy arrays containing:</p> <ul> <li>ADX values</li> </ul> <ul> <li>Smoothed +DM values</li> </ul> <ul> <li>Smoothed -DM values</li> </ul> <ul> <li>Smoothed TR values</li> </ul> <p>Each array has the same length as the input, with the first (2*period-1) elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04, 23.87, 23.67])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64, 23.37, 23.46])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67, 23.78, 23.50])\n&gt;&gt;&gt; adx, plus_dm, minus_dm, tr = kand.adx(high, low, close, 2)\n</code></pre>"},{"location":"api/#kand.adx_inc","title":"<code>adx_inc(high, low, prev_high, prev_low, prev_close, prev_adx, prev_smoothed_plus_dm, prev_smoothed_minus_dm, prev_smoothed_tr, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest ADX value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>high</code> <p>Current period's high price</p> required <code>low</code> <p>Current period's low price</p> required <code>prev_high</code> <p>Previous period's high price</p> required <code>prev_low</code> <p>Previous period's low price</p> required <code>prev_close</code> <p>Previous period's close price</p> required <code>prev_adx</code> <p>Previous period's ADX value</p> required <code>prev_smoothed_plus_dm</code> <p>Previous period's smoothed +DM</p> required <code>prev_smoothed_minus_dm</code> <p>Previous period's smoothed -DM</p> required <code>prev_smoothed_tr</code> <p>Previous period's smoothed TR</p> required <code>period</code> <p>Period for ADX calculation (typically 14)</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Latest ADX value</li> </ul> <ul> <li>New smoothed +DM</li> </ul> <ul> <li>New smoothed -DM</li> </ul> <ul> <li>New smoothed TR</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; adx, plus_dm, minus_dm, tr = kand.adx_inc(\n...     24.20,  # current high\n...     23.85,  # current low\n...     24.07,  # previous high\n...     23.72,  # previous low\n...     23.95,  # previous close\n...     25.0,   # previous ADX\n...     0.5,    # previous smoothed +DM\n...     0.3,    # previous smoothed -DM\n...     1.2,    # previous smoothed TR\n...     14      # period\n... )\n</code></pre>"},{"location":"api/#kand.adxr","title":"<code>adxr(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Calculate Average Directional Index Rating (ADXR) for a NumPy array.</p> <p>ADXR is a momentum indicator that measures the strength of a trend by comparing the current ADX value with the ADX value from <code>period</code> days ago.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for ADX calculation (typically 14).</p> required <p>Returns:</p> Type Description <p>A tuple of 5 1-D NumPy arrays containing:</p> <ul> <li>ADXR values</li> </ul> <ul> <li>ADX values</li> </ul> <ul> <li>Smoothed +DM values</li> </ul> <ul> <li>Smoothed -DM values</li> </ul> <ul> <li>Smoothed TR values</li> </ul> <p>The first (3*period-2) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04, 23.87, 23.67])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64, 23.37, 23.46])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67, 23.78, 23.50])\n&gt;&gt;&gt; adxr, adx, plus_dm, minus_dm, tr = kand.adxr(high, low, close, 2)\n</code></pre>"},{"location":"api/#kand.adxr_inc","title":"<code>adxr_inc(high, low, prev_high, prev_low, prev_close, prev_adx, prev_adx_period_ago, prev_smoothed_plus_dm, prev_smoothed_minus_dm, prev_smoothed_tr, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest ADXR value incrementally</p> <p>Args:</p> <p>high: Current high price as TAFloat.   low: Current low price as TAFloat.   prev_high: Previous high price as TAFloat.   prev_low: Previous low price as TAFloat.   prev_close: Previous close price as TAFloat.   prev_adx: Previous ADX value as TAFloat.   prev_adx_period_ago: ADX value from period days ago as TAFloat.   prev_smoothed_plus_dm: Previous smoothed +DM value as TAFloat.   prev_smoothed_minus_dm: Previous smoothed -DM value as TAFloat.   prev_smoothed_tr: Previous smoothed TR value as TAFloat.   period: Period for ADX calculation (typically 14).</p> <p>Returns:</p> Type Description <p>A tuple of 5 values:</p> <ul> <li>Latest ADXR value</li> </ul> <ul> <li>Latest ADX value</li> </ul> <ul> <li>New smoothed +DM value</li> </ul> <ul> <li>New smoothed -DM value</li> </ul> <ul> <li>New smoothed TR value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; adxr, adx, plus_dm, minus_dm, tr = kand.adxr_inc(\n...     24.20,  # high\n...     23.85,  # low\n...     24.07,  # prev_high\n...     23.72,  # prev_low\n...     23.95,  # prev_close\n...     25.0,   # prev_adx\n...     20.0,   # prev_adx_period_ago\n...     0.5,    # prev_smoothed_plus_dm\n...     0.3,    # prev_smoothed_minus_dm\n...     1.2,    # prev_smoothed_tr\n...     14      # period\n... )\n</code></pre>"},{"location":"api/#kand.aroon","title":"<code>aroon(high, low, period)</code>  <code>builtin</code>","text":"<p>Calculate Aroon indicator for a NumPy array.</p> <p>The Aroon indicator consists of two lines that measure the time since the last high/low relative to a lookback period. It helps identify the start of new trends and trend reversals.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>The lookback period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of 6 1-D NumPy arrays containing:</p> <ul> <li>Aroon Up values</li> </ul> <ul> <li>Aroon Down values</li> </ul> <ul> <li>Previous high values</li> </ul> <ul> <li>Previous low values</li> </ul> <ul> <li>Days since high values</li> </ul> <ul> <li>Days since low values</li> </ul> <p>The first (period) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; aroon_up, aroon_down, prev_high, prev_low, days_high, days_low = kand.aroon(high, low, 3)\n</code></pre>"},{"location":"api/#kand.aroon_inc","title":"<code>aroon_inc(high, low, prev_high, prev_low, days_since_high, days_since_low, period)</code>  <code>builtin</code>","text":"<p>Calculate the next Aroon values incrementally.</p> <p>Args:</p> <p>high: Current period's high price.   low: Current period's low price.   prev_high: Previous highest price in period.   prev_low: Previous lowest price in period.   days_since_high: Days since previous highest price.   days_since_low: Days since previous lowest price.   period: The lookback period (must be &gt;= 2).</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Aroon Up value</li> </ul> <ul> <li>Aroon Down value</li> </ul> <ul> <li>New highest price</li> </ul> <ul> <li>New lowest price</li> </ul> <ul> <li>Updated days since high</li> </ul> <ul> <li>Updated days since low</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; aroon_up, aroon_down, new_high, new_low, days_high, days_low = kand.aroon_inc(\n...     15.0,  # high\n...     12.0,  # low\n...     14.0,  # prev_high\n...     11.0,  # prev_low\n...     2,     # days_since_high\n...     1,     # days_since_low\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.aroonosc","title":"<code>aroonosc(high, low, period)</code>  <code>builtin</code>","text":"<p>Calculate Aroon Oscillator for a NumPy array.</p> <p>The Aroon Oscillator measures the strength of a trend by comparing the time since the last high and low. It oscillates between -100 and +100, with positive values indicating an uptrend and negative values a downtrend.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>The lookback period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of 5 1-D NumPy arrays containing:</p> <ul> <li>Aroon Oscillator values</li> </ul> <ul> <li>Previous high values</li> </ul> <ul> <li>Previous low values</li> </ul> <ul> <li>Days since high values</li> </ul> <ul> <li>Days since low values</li> </ul> <p>The first (period) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; osc, prev_high, prev_low, days_high, days_low = kand.aroonosc(high, low, 3)\n</code></pre>"},{"location":"api/#kand.aroonosc_inc","title":"<code>aroonosc_inc(high, low, prev_high, prev_low, days_since_high, days_since_low, period)</code>  <code>builtin</code>","text":"<p>Calculate the next Aroon Oscillator value incrementally.</p> <p>Args:</p> <p>high: Current period's high price.   low: Current period's low price.   prev_high: Previous highest price within the period.   prev_low: Previous lowest price within the period.   days_since_high: Days since previous highest price.   days_since_low: Days since previous lowest price.   period: The lookback period for calculations (must be &gt;= 2).</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Aroon Oscillator value</li> </ul> <ul> <li>New highest price</li> </ul> <ul> <li>New lowest price</li> </ul> <ul> <li>Updated days since high</li> </ul> <ul> <li>Updated days since low</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; osc, high, low, days_high, days_low = kand.aroonosc_inc(\n...     15.0,  # high\n...     12.0,  # low\n...     14.0,  # prev_high\n...     11.0,  # prev_low\n...     2,     # days_since_high\n...     1,     # days_since_low\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.atr","title":"<code>atr(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Average True Range (ATR) over NumPy arrays.</p> <p>The Average True Range (ATR) is a technical analysis indicator that measures market volatility by decomposing the entire range of an asset price for a given period.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for ATR calculation. Must be greater than 1.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the ATR values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0, 12.0, 11.0])\n&gt;&gt;&gt; result = kand.atr(high, low, close, 3)\n</code></pre>"},{"location":"api/#kand.atr_inc","title":"<code>atr_inc(high, low, prev_close, prev_atr, period)</code>  <code>builtin</code>","text":"<p>Calculate the next ATR value incrementally.</p> <p>Args:</p> <p>high: Current period's high price.   low: Current period's low price.   prev_close: Previous period's close price.   prev_atr: Previous period's ATR value.   period: The time period for ATR calculation (must be &gt;= 2).</p> <p>Returns:</p> Type Description <p>The calculated ATR value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; atr = kand.atr_inc(\n...     15.0,  # high\n...     11.0,  # low\n...     12.0,  # prev_close\n...     3.0,   # prev_atr\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.bbands","title":"<code>bbands(price, period, dev_up, dev_down)</code>  <code>builtin</code>","text":"<p>Calculate Bollinger Bands for a NumPy array.</p> <p>Bollinger Bands consist of: - A middle band (N-period simple moving average) - An upper band (K standard deviations above middle band) - A lower band (K standard deviations below middle band)</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <p>Input price values as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>The time period for calculations (must be &gt;= 2).</p> required <code>dev_up</code> <p>Number of standard deviations for upper band.</p> required <code>dev_down</code> <p>Number of standard deviations for lower band.</p> required <p>Returns:</p> Type Description <p>A tuple of 7 1-D NumPy arrays containing:</p> <ul> <li>Upper band values</li> </ul> <ul> <li>Middle band values</li> </ul> <ul> <li>Lower band values</li> </ul> <ul> <li>SMA values</li> </ul> <ul> <li>Variance values</li> </ul> <ul> <li>Sum values</li> </ul> <ul> <li>Sum of squares values</li> </ul> <p>The first (period-1) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; price = np.array([10.0, 11.0, 12.0, 13.0, 14.0])\n&gt;&gt;&gt; upper, middle, lower, sma, var, sum, sum_sq = kand.bbands(price, 3, 2.0, 2.0)\n</code></pre>"},{"location":"api/#kand.bbands_inc","title":"<code>bbands_inc(price, prev_sma, prev_sum, prev_sum_sq, old_price, period, dev_up, dev_down)</code>  <code>builtin</code>","text":"<p>Calculate the next Bollinger Bands values incrementally.</p> <p>Args:</p> <p>price: The current price value.   prev_sma: The previous SMA value.   prev_sum: The previous sum for variance calculation.   prev_sum_sq: The previous sum of squares for variance calculation.   old_price: The oldest price value to be removed from the period.   period: The time period for calculations (must be &gt;= 2).   dev_up: Number of standard deviations for upper band.   dev_down: Number of standard deviations for lower band.</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Upper Band value</li> </ul> <ul> <li>Middle Band value</li> </ul> <ul> <li>Lower Band value</li> </ul> <ul> <li>New SMA value</li> </ul> <ul> <li>New Sum value</li> </ul> <ul> <li>New Sum of Squares value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; upper, middle, lower, sma, sum, sum_sq = kand.bbands_inc(\n...     10.0,   # price\n...     9.5,    # prev_sma\n...     28.5,   # prev_sum\n...     272.25, # prev_sum_sq\n...     9.0,    # old_price\n...     3,      # period\n...     2.0,    # dev_up\n...     2.0     # dev_down\n... )\n</code></pre>"},{"location":"api/#kand.bop","title":"<code>bop(open, high, low, close)</code>  <code>builtin</code>","text":"<p>Calculate Balance of Power (BOP) indicator for NumPy arrays.</p> <p>The Balance of Power (BOP) is a momentum oscillator that measures the relative strength between buyers and sellers by comparing the closing price to the opening price and normalizing it by the trading range (high - low).</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Input opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Input closing prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing the BOP values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([10.0, 11.0, 12.0, 13.0])\n&gt;&gt;&gt; high = np.array([12.0, 13.0, 14.0, 15.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 10.0, 11.0])\n&gt;&gt;&gt; close = np.array([11.0, 12.0, 13.0, 14.0])\n&gt;&gt;&gt; bop = kand.bop(open, high, low, close)\n</code></pre>"},{"location":"api/#kand.bop_inc","title":"<code>bop_inc(open, high, low, close)</code>  <code>builtin</code>","text":"<p>Calculate a single Balance of Power (BOP) value for the latest price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Current period's opening price</p> required <code>high</code> <p>Current period's high price</p> required <code>low</code> <p>Current period's low price</p> required <code>close</code> <p>Current period's closing price</p> required <p>Returns:</p> Type Description <p>The calculated BOP value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; bop = kand.bop_inc(10.0, 12.0, 8.0, 11.0)\n</code></pre>"},{"location":"api/#kand.cci","title":"<code>cci(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Commodity Channel Index (CCI) over NumPy arrays.</p> <p>The CCI is a momentum-based oscillator used to help determine when an investment vehicle is reaching a condition of being overbought or oversold.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for CCI calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A tuple of 1-D NumPy arrays containing:</p> <ul> <li>CCI values</li> </ul> <ul> <li>Typical prices</li> </ul> <ul> <li>SMA of typical prices</li> </ul> <ul> <li>Mean deviation values</li> </ul> <p>Each array has the same length as the input, with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04, 23.87, 23.67])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64, 23.37, 23.46])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67, 23.78, 23.50])\n&gt;&gt;&gt; cci, tp, sma_tp, mean_dev = kand.cci(high, low, close, 3)\n&gt;&gt;&gt; print(cci)\n[nan, nan, -100.0, 66.67, -133.33]\n</code></pre>"},{"location":"api/#kand.cci_inc","title":"<code>cci_inc(prev_sma_tp, new_high, new_low, new_close, old_high, old_low, old_close, period, tp_buffer)</code>  <code>builtin</code>","text":"<p>Calculates the next CCI value incrementally.</p> <p>Args:</p> <p>prev_sma_tp: Previous SMA value of typical prices.   new_high: New high price.   new_low: New low price.   new_close: New close price.   old_high: Old high price to be removed.   old_low: Old low price to be removed.   old_close: Old close price to be removed.   period: Window size for CCI calculation.   tp_buffer: List containing the last <code>period</code> typical prices.</p> <p>Returns:</p> Type Description <p>The next CCI value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prev_sma_tp = 100.0\n&gt;&gt;&gt; new_high = 105.0\n&gt;&gt;&gt; new_low = 95.0\n&gt;&gt;&gt; new_close = 100.0\n&gt;&gt;&gt; old_high = 102.0\n&gt;&gt;&gt; old_low = 98.0\n&gt;&gt;&gt; old_close = 100.0\n&gt;&gt;&gt; period = 14\n&gt;&gt;&gt; tp_buffer = [100.0] * period\n&gt;&gt;&gt; next_cci = kand.cci_inc(prev_sma_tp, new_high, new_low, new_close,\n...                                  old_high, old_low, old_close, period, tp_buffer)\n</code></pre>"},{"location":"api/#kand.cdl_doji","title":"<code>cdl_doji(open, high, low, close, body_percent, shadow_equal_percent)</code>  <code>builtin</code>","text":"<p>Detects Doji candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>body_percent</code> <p>Maximum body size as percentage of range (e.g. 5.0 for 5%).</p> required <code>shadow_equal_percent</code> <p>Maximum shadow length difference percentage (e.g. 100.0).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing pattern signals (1.0 = pattern, 0.0 = no pattern).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([10.0, 10.5, 10.2])\n&gt;&gt;&gt; high = np.array([11.0, 11.2, 10.8])\n&gt;&gt;&gt; low = np.array([9.8, 10.1, 9.9])\n&gt;&gt;&gt; close = np.array([10.3, 10.4, 10.25])\n&gt;&gt;&gt; signals = kand.cdl_doji(open, high, low, close, 5.0, 100.0)\n</code></pre>"},{"location":"api/#kand.cdl_doji_inc","title":"<code>cdl_doji_inc(open, high, low, close, body_percent, shadow_equal_percent)</code>  <code>builtin</code>","text":"<p>Detects a Doji pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   body_percent: Maximum body size as percentage of range.   shadow_equal_percent: Maximum shadow length difference percentage.</p> <p>Returns:</p> Type Description <p>Signal value (1.0 for Doji pattern, 0.0 for no pattern).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal = kand.cdl_doji_inc(10.0, 11.0, 9.8, 10.3, 5.0, 100.0)\n</code></pre>"},{"location":"api/#kand.cdl_dragonfly_doji","title":"<code>cdl_dragonfly_doji(open, high, low, close, body_percent)</code>  <code>builtin</code>","text":"<p>Detects Dragonfly Doji candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>body_percent</code> <p>Maximum body size as percentage of total range (typically 5%).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing pattern signals:</p> <ul> <li>100: Bullish Dragonfly Doji pattern detected</li> </ul> <ul> <li>0: No pattern detected</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals = kand.cdl_dragonfly_doji(open, high, low, close, 5.0)\n</code></pre>"},{"location":"api/#kand.cdl_dragonfly_doji_inc","title":"<code>cdl_dragonfly_doji_inc(open, high, low, close, body_percent)</code>  <code>builtin</code>","text":"<p>Detects a Dragonfly Doji pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   body_percent: Maximum body size as percentage of total range.</p> <p>Returns:</p> Type Description <p>Signal value:</p> <ul> <li>100: Bullish Dragonfly Doji pattern detected</li> </ul> <ul> <li>0: No pattern detected</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal = kand.cdl_dragonfly_doji_inc(100.0, 102.0, 98.0, 100.1, 5.0)\n</code></pre>"},{"location":"api/#kand.cdl_gravestone_doji","title":"<code>cdl_gravestone_doji(open, high, low, close, body_percent)</code>  <code>builtin</code>","text":"<p>Detects Gravestone Doji candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>body_percent</code> <p>Maximum body size as percentage of total range (typically 5%).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing pattern signals:</p> <ul> <li>-100: Bearish Gravestone Doji pattern detected</li> </ul> <ul> <li>0: No pattern detected</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals = kand.cdl_gravestone_doji(open, high, low, close, 5.0)\n</code></pre>"},{"location":"api/#kand.cdl_gravestone_doji_inc","title":"<code>cdl_gravestone_doji_inc(open, high, low, close, body_percent)</code>  <code>builtin</code>","text":"<p>Detects a Gravestone Doji pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   body_percent: Maximum body size as percentage of total range.</p> <p>Returns:</p> Type Description <p>Signal value:</p> <ul> <li>-100: Bearish Gravestone Doji pattern detected</li> </ul> <ul> <li>0: No pattern detected</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal = kand.cdl_gravestone_doji_inc(100.0, 102.0, 98.0, 100.1, 5.0)\n</code></pre>"},{"location":"api/#kand.cdl_hammer","title":"<code>cdl_hammer(open, high, low, close, period, factor)</code>  <code>builtin</code>","text":"<p>Detects Hammer candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for EMA calculation of body sizes.</p> required <code>factor</code> <p>Minimum ratio of lower shadow to body length.</p> required <p>Returns:</p> Type Description <p>A tuple of two 1-D NumPy arrays containing:</p> <ul> <li>Pattern signals:</li> <li>100: Bullish Hammer pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>EMA values of candle body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals, body_avg = kand.cdl_hammer(open, high, low, close, 14, 2.0)\n</code></pre>"},{"location":"api/#kand.cdl_hammer_inc","title":"<code>cdl_hammer_inc(open, high, low, close, prev_body_avg, period, factor)</code>  <code>builtin</code>","text":"<p>Detects a Hammer pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   prev_body_avg: Previous EMA value of body sizes.   period: Period for EMA calculation.   factor: Minimum ratio of lower shadow to body length.</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Signal value:</li> <li>100: Bullish Hammer pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>Updated EMA value of body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal, body_avg = kand.cdl_hammer_inc(100.0, 102.0, 98.0, 100.1, 0.5, 14, 2.0)\n</code></pre>"},{"location":"api/#kand.cdl_inverted_hammer","title":"<code>cdl_inverted_hammer(open, high, low, close, period, factor)</code>  <code>builtin</code>","text":"<p>Detects Inverted Hammer candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for EMA calculation of body sizes.</p> required <code>factor</code> <p>Minimum ratio of upper shadow to body length.</p> required <p>Returns:</p> Type Description <p>A tuple of two 1-D NumPy arrays containing:</p> <ul> <li>Pattern signals:</li> <li>100: Bullish Inverted Hammer pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>EMA values of candle body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals, body_avg = kand.cdl_inverted_hammer(open, high, low, close, 14, 2.0)\n</code></pre>"},{"location":"api/#kand.cdl_inverted_hammer_inc","title":"<code>cdl_inverted_hammer_inc(open, high, low, close, prev_body_avg, period, factor)</code>  <code>builtin</code>","text":"<p>Detects an Inverted Hammer pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   prev_body_avg: Previous EMA value of body sizes.   period: Period for EMA calculation.   factor: Minimum ratio of upper shadow to body length.</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Signal value:</li> <li>100: Bullish Inverted Hammer pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>Updated EMA value of body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal, body_avg = kand.cdl_inverted_hammer_inc(100.0, 102.0, 98.0, 100.1, 0.5, 14, 2.0)\n</code></pre>"},{"location":"api/#kand.cdl_long_shadow","title":"<code>cdl_long_shadow(open, high, low, close, period, shadow_factor)</code>  <code>builtin</code>","text":"<p>Detects Long Shadow candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for EMA calculation of body sizes.</p> required <code>shadow_factor</code> <p>Minimum percentage of total range that shadow must be.</p> required <p>Returns:</p> Type Description <p>A tuple of two 1-D NumPy arrays containing:</p> <ul> <li>Pattern signals:</li> <li>100: Bullish Long Lower Shadow pattern detected</li> <li>-100: Bearish Long Upper Shadow pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>EMA values of candle body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals, body_avg = kand.cdl_long_shadow(open, high, low, close, 14, 75.0)\n</code></pre>"},{"location":"api/#kand.cdl_long_shadow_inc","title":"<code>cdl_long_shadow_inc(open, high, low, close, prev_body_avg, period, shadow_factor)</code>  <code>builtin</code>","text":"<p>Detects a Long Shadow pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   prev_body_avg: Previous EMA value of body sizes.   period: Period for EMA calculation.   shadow_factor: Minimum percentage of total range that shadow must be.</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Signal value:</li> <li>100: Bullish Long Lower Shadow pattern detected</li> <li>-100: Bearish Long Upper Shadow pattern detected</li> <li>0: No pattern detected</li> </ul> <ul> <li>Updated EMA value of body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal, body_avg = kand.cdl_long_shadow_inc(100.0, 102.0, 98.0, 100.1, 0.5, 14, 75.0)\n</code></pre>"},{"location":"api/#kand.cdl_marubozu","title":"<code>cdl_marubozu(open, high, low, close, period, shadow_percent)</code>  <code>builtin</code>","text":"<p>Detects Marubozu candlestick patterns in price data.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <p>Opening prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for EMA calculation of body sizes.</p> required <code>shadow_percent</code> <p>Maximum shadow size as percentage of body.</p> required <p>Returns:</p> Type Description <p>A tuple of two 1-D NumPy arrays containing:</p> <ul> <li>Pattern signals:</li> <li>1.0: Bullish Marubozu pattern detected</li> <li>-1.0: Bearish Marubozu pattern detected</li> <li>0.0: No pattern detected</li> </ul> <ul> <li>EMA values of candle body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; open = np.array([100.0, 101.0, 102.0])\n&gt;&gt;&gt; high = np.array([102.0, 103.0, 104.0])\n&gt;&gt;&gt; low = np.array([98.0, 99.0, 100.0])\n&gt;&gt;&gt; close = np.array([101.0, 102.0, 103.0])\n&gt;&gt;&gt; signals, body_avg = kand.cdl_marubozu(open, high, low, close, 14, 5.0)\n</code></pre>"},{"location":"api/#kand.cdl_marubozu_inc","title":"<code>cdl_marubozu_inc(open, high, low, close, prev_body_avg, period, shadow_percent)</code>  <code>builtin</code>","text":"<p>Detects a Marubozu pattern in a single candlestick.</p> <p>Args:</p> <p>open: Opening price.   high: High price.   low: Low price.   close: Close price.   prev_body_avg: Previous EMA value of body sizes.   period: Period for EMA calculation.   shadow_percent: Maximum shadow size as percentage of body.</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Signal value:</li> <li>1.0: Bullish Marubozu pattern detected</li> <li>-1.0: Bearish Marubozu pattern detected</li> <li>0.0: No pattern detected</li> </ul> <ul> <li>Updated EMA value of body sizes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; signal, body_avg = kand.cdl_marubozu_inc(100.0, 102.0, 98.0, 100.1, 0.5, 14, 5.0)\n</code></pre>"},{"location":"api/#kand.correl","title":"<code>correl(input0, input1, period)</code>  <code>builtin</code>","text":"<p>Calculate Pearson's Correlation Coefficient between two NumPy arrays</p> <p>The Pearson Correlation Coefficient measures the linear correlation between two variables, returning a value between -1 and +1, where: - +1 indicates perfect positive correlation - -1 indicates perfect negative correlation - 0 indicates no linear correlation</p> <p>Parameters:</p> Name Type Description Default <code>input0</code> <p>First input series as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>input1</code> <p>Second input series as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of six 1-D NumPy arrays containing:</p> <ul> <li>Correlation coefficient values</li> </ul> <ul> <li>Running sum of series 0</li> </ul> <ul> <li>Running sum of series 1</li> </ul> <ul> <li>Running sum of squares of series 0</li> </ul> <ul> <li>Running sum of squares of series 1</li> </ul> <ul> <li>Running sum of products</li> </ul> <p>Each array has the same length as the input, with the first (period-1) elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; series1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; series2 = np.array([2.0, 4.0, 6.0, 8.0, 10.0])\n&gt;&gt;&gt; correl, sum0, sum1, sum0_sq, sum1_sq, sum01 = kand.correl(series1, series2, 3)\n</code></pre>"},{"location":"api/#kand.correl_inc","title":"<code>correl_inc(new0, new1, old0, old1, prev_sum0, prev_sum1, prev_sum0_sq, prev_sum1_sq, prev_sum01, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest Correlation value incrementally</p> <p>This function provides an optimized way to update the Correlation value when new data arrives, avoiding full recalculation of the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>new0</code> <p>The newest value from series 0 to add</p> required <code>new1</code> <p>The newest value from series 1 to add</p> required <code>old0</code> <p>The oldest value from series 0 to remove</p> required <code>old1</code> <p>The oldest value from series 1 to remove</p> required <code>prev_sum0</code> <p>Previous sum of series 0</p> required <code>prev_sum1</code> <p>Previous sum of series 1</p> required <code>prev_sum0_sq</code> <p>Previous sum of squares of series 0</p> required <code>prev_sum1_sq</code> <p>Previous sum of squares of series 1</p> required <code>prev_sum01</code> <p>Previous sum of products</p> required <code>period</code> <p>Period for calculation (must be &gt;= 2)</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>New correlation value</li> </ul> <ul> <li>New sum of series 0</li> </ul> <ul> <li>New sum of series 1</li> </ul> <ul> <li>New sum of squares of series 0</li> </ul> <ul> <li>New sum of squares of series 1</li> </ul> <ul> <li>New sum of products</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; correl, sum0, sum1, sum0_sq, sum1_sq, sum01 = kand.correl_inc(\n...     4.0,    # new value for series 0\n...     8.0,    # new value for series 1\n...     1.0,    # old value for series 0\n...     2.0,    # old value for series 1\n...     6.0,    # previous sum of series 0\n...     12.0,   # previous sum of series 1\n...     14.0,   # previous sum of squares of series 0\n...     56.0,   # previous sum of squares of series 1\n...     28.0,   # previous sum of products\n...     3       # period\n... )\n</code></pre>"},{"location":"api/#kand.dema","title":"<code>dema(input_price, period)</code>  <code>builtin</code>","text":"<p>Calculates Double Exponential Moving Average (DEMA) over NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>input_price</code> <p>Price values as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period for EMA calculations. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A tuple of 1-D NumPy arrays containing:</p> <ul> <li>DEMA values</li> </ul> <ul> <li>First EMA values</li> </ul> <ul> <li>Second EMA values</li> </ul> <p>Each array has the same length as the input, with the first <code>2*(period-1)</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])\n&gt;&gt;&gt; dema, ema1, ema2 = kand.dema(prices, 3)\n</code></pre>"},{"location":"api/#kand.dema_inc","title":"<code>dema_inc(price, prev_ema1, prev_ema2, period)</code>  <code>builtin</code>","text":"<p>Calculates the next DEMA value incrementally.</p> <p>Args:</p> <p>price: Current price value.   prev_ema1: Previous value of first EMA.   prev_ema2: Previous value of second EMA.   period: Smoothing period. Must be &gt;= 2.</p> <p>Returns:</p> Type Description <p>A tuple containing (DEMA, new_ema1, new_ema2).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; dema, ema1, ema2 = kand.dema_inc(10.0, 9.5, 9.0, 3)\n</code></pre>"},{"location":"api/#kand.dx","title":"<code>dx(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Directional Movement Index (DX) over NumPy arrays.</p> <p>The DX indicator measures the strength of a trend by comparing positive and negative directional movements.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for DX calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A tuple of four 1-D NumPy arrays containing:</p> <ul> <li>DX values</li> </ul> <ul> <li>Smoothed +DM values</li> </ul> <ul> <li>Smoothed -DM values</li> </ul> <ul> <li>Smoothed TR values</li> </ul> <p>Each array has the same length as the input, with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04, 23.87, 23.67])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64, 23.37, 23.46])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67, 23.78, 23.50])\n&gt;&gt;&gt; dx, plus_dm, minus_dm, tr = kand.dx(high, low, close, 3)\n</code></pre>"},{"location":"api/#kand.dx_inc","title":"<code>dx_inc(input_high, input_low, prev_high, prev_low, prev_close, prev_smoothed_plus_dm, prev_smoothed_minus_dm, prev_smoothed_tr, param_period)</code>  <code>builtin</code>","text":"<p>Calculates the latest DX value incrementally.</p> <p>Computes only the most recent DX value using previous smoothed values. Optimized for real-time calculations where only the latest value is needed.</p> <p>For the formula, refer to the [<code>dx</code>] function documentation.</p> <p>Parameters:</p> Name Type Description Default <code>input_high</code> <code>float</code> <p>Current high price.</p> required <code>input_low</code> <code>float</code> <p>Current low price.</p> required <code>prev_high</code> <code>float</code> <p>Previous period's high price.</p> required <code>prev_low</code> <code>float</code> <p>Previous period's low price.</p> required <code>prev_close</code> <code>float</code> <p>Previous period's close price.</p> required <code>prev_smoothed_plus_dm</code> <code>float</code> <p>Previous smoothed +DM value.</p> required <code>prev_smoothed_minus_dm</code> <code>float</code> <p>Previous smoothed -DM value.</p> required <code>prev_smoothed_tr</code> <code>float</code> <p>Previous smoothed TR value.</p> required <code>param_period</code> <code>int</code> <p>Period for DX calculation (typically 14).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing: - Latest DX value (float) - New smoothed +DM (float) - New smoothed -DM (float) - New smoothed TR (float)</p> Example <p>import kand high, low = 24.20, 23.85 prev_high, prev_low, prev_close = 24.07, 23.72, 23.95 prev_smoothed_plus_dm = 0.5 prev_smoothed_minus_dm = 0.3 prev_smoothed_tr = 1.2 period = 14 dx, plus_dm, minus_dm, tr = kand.dx_inc( ...     high, low, prev_high, prev_low, prev_close, ...     prev_smoothed_plus_dm, prev_smoothed_minus_dm, ...     prev_smoothed_tr, period)</p>"},{"location":"api/#kand.ecl","title":"<code>ecl(high, low, close)</code>  <code>builtin</code>","text":"<p>Computes the Expanded Camarilla Levels (ECL) over NumPy arrays.</p> <p>The ECL indicator calculates multiple support and resistance levels based on the previous period's high, low and close prices.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Input close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A tuple of ten 1-D NumPy arrays containing the ECL values (H5,H4,H3,H2,H1,L1,L2,L3,L4,L5).</p> <p>Each array has the same length as the input, with the first element containing NaN value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04, 23.87, 23.67])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64, 23.37, 23.46])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67, 23.78, 23.50])\n&gt;&gt;&gt; h5,h4,h3,h2,h1,l1,l2,l3,l4,l5 = kand.ecl(high, low, close)\n</code></pre>"},{"location":"api/#kand.ecl_inc","title":"<code>ecl_inc(prev_high, prev_low, prev_close)</code>  <code>builtin</code>","text":"<p>Computes the latest Expanded Camarilla Levels (ECL) values incrementally.</p> <p>This function provides an efficient way to calculate ECL values for new data without reprocessing the entire dataset.</p> <p>Args:</p> <p>prev_high: Previous period's high price as <code>TAFloat</code>.   prev_low: Previous period's low price as <code>TAFloat</code>.   prev_close: Previous period's close price as <code>TAFloat</code>.</p> <p>Returns:</p> Type Description <p>A tuple of ten values (H5,H4,H3,H2,H1,L1,L2,L3,L4,L5) containing the latest ECL levels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; h5,h4,h3,h2,h1,l1,l2,l3,l4,l5 = kand.ecl_inc(24.20, 23.85, 23.89)\n</code></pre>"},{"location":"api/#kand.ema","title":"<code>ema(data, period, k=None)</code>  <code>builtin</code>","text":"<p>Computes the Exponential Moving Average (EMA) over a NumPy array.</p> <p>The Exponential Moving Average is calculated by applying more weight to recent prices via a smoothing factor k. Each value is calculated as: EMA = Price * k + EMA(previous) * (1 - k) where k is typically 2/(period+1).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for EMA calculation. Must be positive and less than input length.</p> required <code>k</code> <p>Optional custom smoothing factor. If None, uses default k = 2/(period+1).</p> <code>None</code> <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the EMA values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; result = kand.ema(data, 3)\n&gt;&gt;&gt; print(result)\n[nan, nan, 2.0, 3.0, 4.2]\n</code></pre>"},{"location":"api/#kand.ema_inc","title":"<code>ema_inc(price, prev_ema, period, k=None)</code>  <code>builtin</code>","text":"<p>Computes the latest EMA value incrementally.</p> <p>This function provides an efficient way to calculate EMA values for new data without reprocessing the entire dataset.</p> <p>Args:</p> <p>price: Current period's price value as <code>TAFloat</code>.   prev_ema: Previous period's EMA value as <code>TAFloat</code>.   period: Window size for EMA calculation. Must be &gt;= 2.   k: Optional custom smoothing factor. If None, uses default k = 2/(period+1).</p> <p>Returns:</p> Type Description <p>The new EMA value as <code>TAFloat</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; current_price = 15.0\n&gt;&gt;&gt; prev_ema = 14.5\n&gt;&gt;&gt; period = 14\n&gt;&gt;&gt; new_ema = kand.ema_inc(current_price, prev_ema, period)\n</code></pre>"},{"location":"api/#kand.macd","title":"<code>macd(data, fast_period, slow_period, signal_period)</code>  <code>builtin</code>","text":"<p>Computes the Moving Average Convergence Divergence (MACD) over a NumPy array.</p> <p>MACD is a trend-following momentum indicator that shows the relationship between two moving averages of an asset's price. It consists of three components: - MACD Line: Difference between fast and slow EMAs - Signal Line: EMA of the MACD line - Histogram: Difference between MACD line and signal line</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>fast_period</code> <p>Period for fast EMA calculation (typically 12).</p> required <code>slow_period</code> <p>Period for slow EMA calculation (typically 26).</p> required <code>signal_period</code> <p>Period for signal line calculation (typically 9).</p> required <p>Returns:</p> Type Description <p>A tuple of five 1-D NumPy arrays containing:</p> <ul> <li>MACD line values</li> </ul> <ul> <li>Signal line values</li> </ul> <ul> <li>MACD histogram values</li> </ul> <ul> <li>Fast EMA values</li> </ul> <ul> <li>Slow EMA values</li> </ul> <p>Each array has the same length as the input, with initial elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; macd_line, signal_line, histogram, fast_ema, slow_ema = kand.macd(data, 2, 3, 2)\n</code></pre>"},{"location":"api/#kand.macd_inc","title":"<code>macd_inc(price, prev_fast_ema, prev_slow_ema, prev_signal, fast_period, slow_period, signal_period)</code>  <code>builtin</code>","text":"<p>Computes the latest MACD values incrementally from previous state.</p> <p>This function provides an efficient way to calculate MACD for streaming data by using previous EMA values instead of recalculating the entire series.</p> <p>Args:</p> <p>price: Current price value as <code>TAFloat</code>.   prev_fast_ema: Previous fast EMA value as <code>TAFloat</code>.   prev_slow_ema: Previous slow EMA value as <code>TAFloat</code>.   prev_signal: Previous signal line value as <code>TAFloat</code>.   fast_period: Period for fast EMA calculation (typically 12).   slow_period: Period for slow EMA calculation (typically 26).   signal_period: Period for signal line calculation (typically 9).</p> <p>Returns:</p> Type Description <p>A tuple of three values:</p> <ul> <li>MACD line value</li> </ul> <ul> <li>Signal line value</li> </ul> <ul> <li>MACD histogram value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; macd_line, signal_line, histogram = kand.macd_inc(\n...     100.0,  # current price\n...     95.0,   # previous fast EMA\n...     98.0,   # previous slow EMA\n...     -2.5,   # previous signal\n...     12,     # fast period\n...     26,     # slow period\n...     9       # signal period\n... )\n</code></pre>"},{"location":"api/#kand.max","title":"<code>max(prices, period)</code>  <code>builtin</code>","text":"<p>Calculate Maximum Value for a NumPy array</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for MAX calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing MAX values. The first (period-1) elements contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 2.5, 4.0])\n&gt;&gt;&gt; max_values = kand.max(prices, 3)\n</code></pre>"},{"location":"api/#kand.max_inc","title":"<code>max_inc(price, prev_max, old_price, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest Maximum Value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>price</code> <p>Current period's price</p> required <code>prev_max</code> <p>Previous period's MAX value</p> required <code>old_price</code> <p>Price being removed from the period</p> required <code>period</code> <p>Period for MAX calculation (must be &gt;= 2)</p> required <p>Returns:</p> Type Description <p>The new MAX value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_max = kand.max_inc(10.5, 11.0, 9.0, 14)\n</code></pre>"},{"location":"api/#kand.medprice","title":"<code>medprice(high, low)</code>  <code>builtin</code>","text":"<p>Calculates the Median Price (MEDPRICE) for a NumPy array.</p> <p>The Median Price is a technical analysis indicator that represents the middle point between high and low prices for each period.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Array of high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Array of low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing the median price values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 11.0, 12.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 10.0])\n&gt;&gt;&gt; result = kand.medprice(high, low)\n&gt;&gt;&gt; print(result)\n[9.0, 10.0, 11.0]\n</code></pre>"},{"location":"api/#kand.medprice_inc","title":"<code>medprice_inc(high, low)</code>  <code>builtin</code>","text":"<p>Calculates a single Median Price value incrementally.</p> <p>Args:</p> <p>high: Current period's high price as <code>TAFloat</code>.   low: Current period's low price as <code>TAFloat</code>.</p> <p>Returns:</p> Type Description <p>The calculated median price value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; result = kand.medprice_inc(10.0, 8.0)\n&gt;&gt;&gt; print(result)\n9.0\n</code></pre>"},{"location":"api/#kand.mfi","title":"<code>mfi(high, low, close, volume, period)</code>  <code>builtin</code>","text":"<p>Calculates the Money Flow Index (MFI) for a NumPy array.</p> <p>The Money Flow Index (MFI) is a technical oscillator that uses price and volume data to identify overbought or oversold conditions in an asset.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Array of high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Array of low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Array of close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>volume</code> <p>Array of volume data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>The time period for MFI calculation (typically 14).</p> required <p>Returns:</p> Type Description <p>A tuple of five 1-D NumPy arrays containing:</p> <ul> <li>MFI values (0-100)</li> </ul> <ul> <li>Typical prices</li> </ul> <ul> <li>Money flows</li> </ul> <ul> <li>Positive money flows</li> </ul> <ul> <li>Negative money flows</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 11.0, 12.0, 11.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 10.0, 11.0, 10.0])\n&gt;&gt;&gt; volume = np.array([100.0, 150.0, 200.0, 150.0])\n&gt;&gt;&gt; mfi, typ_prices, money_flows, pos_flows, neg_flows = kand.mfi(high, low, close, volume, 2)\n</code></pre>"},{"location":"api/#kand.midpoint","title":"<code>midpoint(data, period)</code>  <code>builtin</code>","text":"<p>Calculates Midpoint values for a NumPy array.</p> <p>The Midpoint is a technical indicator that represents the arithmetic mean of the highest and lowest prices over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Time period for calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Midpoint values</li> </ul> <ul> <li>Highest values for each period</li> </ul> <ul> <li>Lowest values for each period</li> </ul> <p>Each array has the same length as the input, with initial elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; midpoint, highest, lowest = kand.midpoint(data, 3)\n</code></pre>"},{"location":"api/#kand.midpoint_inc","title":"<code>midpoint_inc(price, prev_highest, prev_lowest, period)</code>  <code>builtin</code>","text":"<p>Calculates the next Midpoint value incrementally.</p> <p>Provides an optimized way to calculate the next Midpoint value when new data arrives, without recalculating the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <p>Current price value as <code>TAFloat</code>.</p> required <code>prev_highest</code> <p>Previous highest value as <code>TAFloat</code>.</p> required <code>prev_lowest</code> <p>Previous lowest value as <code>TAFloat</code>.</p> required <code>period</code> <p>Time period for calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Midpoint value</li> </ul> <ul> <li>New highest value</li> </ul> <ul> <li>New lowest value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; midpoint, new_highest, new_lowest = kand.midpoint_inc(\n...     15.0,  # current price\n...     16.0,  # previous highest\n...     14.0,  # previous lowest\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.midprice","title":"<code>midprice(high, low, period)</code>  <code>builtin</code>","text":"<p>Calculates Midpoint Price values for a NumPy array.</p> <p>The Midpoint Price is a technical indicator that represents the mean value between the highest high and lowest low prices over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Time period for calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Midpoint Price values</li> </ul> <ul> <li>Highest high values for each period</li> </ul> <ul> <li>Lowest low values for each period</li> </ul> <p>Each array has the same length as the input, with initial elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; midprice, highest, lowest = kand.midprice(high, low, 3)\n</code></pre>"},{"location":"api/#kand.midprice_inc","title":"<code>midprice_inc(high, low, prev_highest, prev_lowest, period)</code>  <code>builtin</code>","text":"<p>Calculates the next Midpoint Price value incrementally.</p> <p>Provides an optimized way to calculate the next Midpoint Price value when new data arrives, without recalculating the entire series.</p> <p>Args:</p> <p>high: Current high price value as <code>TAFloat</code>.   low: Current low price value as <code>TAFloat</code>.   prev_highest: Previous highest high value as <code>TAFloat</code>.   prev_lowest: Previous lowest low value as <code>TAFloat</code>.   period: Time period for calculation (must be &gt;= 2).</p> <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Midpoint Price value</li> </ul> <ul> <li>New highest high value</li> </ul> <ul> <li>New lowest low value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; midprice, new_highest, new_lowest = kand.midprice_inc(\n...     10.5,  # current high\n...     9.8,   # current low\n...     10.2,  # previous highest high\n...     9.5,   # previous lowest low\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.min","title":"<code>min(prices, period)</code>  <code>builtin</code>","text":"<p>Calculate Minimum Value (MIN) for a NumPy array</p> <p>The MIN indicator finds the lowest price value within a given time period.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for MIN calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing MIN values. First (period-1) elements contain NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([10.0, 8.0, 6.0, 7.0, 9.0])\n&gt;&gt;&gt; min_values = kand.min(prices, 3)\n</code></pre>"},{"location":"api/#kand.min_inc","title":"<code>min_inc(price, prev_min, prev_price, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest MIN value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>price</code> <p>Current period's price</p> required <code>prev_min</code> <p>Previous period's MIN value</p> required <code>prev_price</code> <p>Price value being removed from the period</p> required <code>period</code> <p>Period for MIN calculation (must be &gt;= 2)</p> required <p>Returns:</p> Type Description <p>The new MIN value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_min = kand.min_inc(15.0, 12.0, 14.0, 14)\n</code></pre>"},{"location":"api/#kand.minus_di","title":"<code>minus_di(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Minus Directional Indicator (-DI) over NumPy arrays.</p> <p>The -DI measures the presence and strength of a downward price trend. It is one component used in calculating the Average Directional Index (ADX), which helps determine trend strength.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for -DI calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>The -DI values</li> </ul> <ul> <li>The smoothed -DM values</li> </ul> <ul> <li>The smoothed TR values</li> </ul> <p>Each array has the same length as the input, with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([35.0, 36.0, 35.5, 35.8, 36.2])\n&gt;&gt;&gt; low = np.array([34.0, 35.0, 34.5, 34.8, 35.2])\n&gt;&gt;&gt; close = np.array([34.5, 35.5, 35.0, 35.3, 35.7])\n&gt;&gt;&gt; minus_di, smoothed_minus_dm, smoothed_tr = kand.minus_di(high, low, close, 3)\n&gt;&gt;&gt; print(minus_di)\n[nan, nan, nan, 25.3, 24.1]\n</code></pre>"},{"location":"api/#kand.minus_dm","title":"<code>minus_dm(high, low, period)</code>  <code>builtin</code>","text":"<p>Computes the Minus Directional Movement (-DM) over NumPy arrays.</p> <p>Minus Directional Movement (-DM) measures downward price movement and is used as part of the Directional Movement System developed by J. Welles Wilder.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for -DM calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the -DM values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([35266.0, 35247.5, 35235.7, 35190.8, 35182.0])\n&gt;&gt;&gt; low = np.array([35216.1, 35206.5, 35180.0, 35130.7, 35153.6])\n&gt;&gt;&gt; result = kand.minus_dm(high, low, 3)\n</code></pre>"},{"location":"api/#kand.mom","title":"<code>mom(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Momentum (MOM) over a NumPy array.</p> <p>Momentum measures the change in price between the current price and the price n periods ago.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for momentum calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the momentum values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([2.0, 4.0, 6.0, 8.0, 10.0])\n&gt;&gt;&gt; result = kand.mom(data, 2)\n&gt;&gt;&gt; print(result)\n[nan, nan, 4.0, 4.0, 4.0]\n</code></pre>"},{"location":"api/#kand.mom_inc","title":"<code>mom_inc(current_price, old_price)</code>  <code>builtin</code>","text":"<p>Calculates the next Momentum (MOM) value incrementally.</p> <p>This function provides an optimized way to calculate the latest momentum value when streaming data is available, without needing the full price history.</p> <p>Args:</p> <p>current_price: The current period's price value.   old_price: The price value from n periods ago.</p> <p>Returns:</p> Type Description <p>The calculated momentum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; momentum = kand.mom_inc(10.0, 6.0)\n&gt;&gt;&gt; print(momentum)\n4.0\n</code></pre>"},{"location":"api/#kand.natr","title":"<code>natr(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Normalized Average True Range (NATR) over NumPy arrays.</p> <p>The NATR is a measure of volatility that accounts for the price level of the instrument. It expresses the ATR as a percentage of the closing price.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for NATR calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the NATR values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0, 12.0, 11.0])\n&gt;&gt;&gt; result = kand.natr(high, low, close, 3)\n</code></pre>"},{"location":"api/#kand.natr_inc","title":"<code>natr_inc(high, low, close, prev_close, prev_atr, period)</code>  <code>builtin</code>","text":"<p>Calculates the next NATR value incrementally.</p> <p>This function provides an optimized way to calculate a single new NATR value using the previous ATR value and current price data, without recalculating the entire series.</p> <p>Args:</p> <p>high: Current period's high price.   low: Current period's low price.   close: Current period's closing price.   prev_close: Previous period's closing price.   prev_atr: Previous period's ATR value.   period: Period for NATR calculation (must be &gt;= 2).</p> <p>Returns:</p> Type Description <p>The calculated NATR value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; natr = kand.natr_inc(\n...     15.0,  # high\n...     11.0,  # low\n...     14.0,  # close\n...     12.0,  # prev_close\n...     3.0,   # prev_atr\n...     3      # period\n... )\n</code></pre>"},{"location":"api/#kand.obv","title":"<code>obv(close, volume)</code>  <code>builtin</code>","text":"<p>Computes the On Balance Volume (OBV) over NumPy arrays.</p> <p>On Balance Volume (OBV) is a momentum indicator that uses volume flow to predict changes in stock price. When volume increases without a significant price change, the price will eventually jump upward. When volume decreases without a significant price change, the price will eventually jump downward.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>volume</code> <p>Volume data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the OBV values. The array has the same length as the input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; close = np.array([10.0, 12.0, 11.0, 13.0])\n&gt;&gt;&gt; volume = np.array([100.0, 150.0, 120.0, 200.0])\n&gt;&gt;&gt; result = kand.obv(close, volume)\n&gt;&gt;&gt; print(result)\n[100.0, 250.0, 130.0, 330.0]\n</code></pre>"},{"location":"api/#kand.obv_inc","title":"<code>obv_inc(curr_close, prev_close, volume, prev_obv)</code>  <code>builtin</code>","text":"<p>Calculates the next OBV value incrementally.</p> <p>This function provides an optimized way to calculate a single new OBV value using the previous OBV value and current price/volume data.</p> <p>Parameters:</p> Name Type Description Default <code>curr_close</code> <p>Current closing price as <code>TAFloat</code>.</p> required <code>prev_close</code> <p>Previous closing price as <code>TAFloat</code>.</p> required <code>volume</code> <p>Current volume as <code>TAFloat</code>.</p> required <code>prev_obv</code> <p>Previous OBV value as <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>The calculated OBV value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; curr_close = 12.0\n&gt;&gt;&gt; prev_close = 10.0\n&gt;&gt;&gt; volume = 150.0\n&gt;&gt;&gt; prev_obv = 100.0\n&gt;&gt;&gt; result = kand.obv_inc(curr_close, prev_close, volume, prev_obv)\n&gt;&gt;&gt; print(result)\n250.0\n</code></pre>"},{"location":"api/#kand.plus_di","title":"<code>plus_di(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Computes the Plus Directional Indicator (+DI) over NumPy arrays.</p> <p>+DI measures the presence and strength of an upward price trend. It is one component used in calculating the Average Directional Index (ADX), which helps determine trend strength.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for +DI calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>+DI values</li> </ul> <ul> <li>Smoothed +DM values</li> </ul> <ul> <li>Smoothed TR values</li> </ul> <p>Each array has the same length as the input, with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 11.5, 11.0])\n&gt;&gt;&gt; low = np.array([9.0, 10.0, 10.0, 9.5])\n&gt;&gt;&gt; close = np.array([9.5, 11.0, 10.5, 10.0])\n&gt;&gt;&gt; plus_di, smoothed_plus_dm, smoothed_tr = kand.plus_di(high, low, close, 2)\n</code></pre>"},{"location":"api/#kand.plus_di_inc","title":"<code>plus_di_inc(high, low, prev_high, prev_low, prev_close, prev_smoothed_plus_dm, prev_smoothed_tr, period)</code>  <code>builtin</code>","text":"<p>Calculates the next +DI value incrementally using previous smoothed values.</p> <p>This function enables real-time calculation of +DI by using the previous smoothed values and current price data, avoiding the need to recalculate the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current high price as <code>TAFloat</code>.</p> required <code>low</code> <p>Current low price as <code>TAFloat</code>.</p> required <code>prev_high</code> <p>Previous high price as <code>TAFloat</code>.</p> required <code>prev_low</code> <p>Previous low price as <code>TAFloat</code>.</p> required <code>prev_close</code> <p>Previous close price as <code>TAFloat</code>.</p> required <code>prev_smoothed_plus_dm</code> <p>Previous smoothed +DM value as <code>TAFloat</code>.</p> required <code>prev_smoothed_tr</code> <p>Previous smoothed TR value as <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period (&gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple containing (latest +DI, new smoothed +DM, new smoothed TR).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; plus_di, smoothed_plus_dm, smoothed_tr = kand.plus_di_inc(\n...     10.5,  # high\n...     9.5,   # low\n...     10.0,  # prev_high\n...     9.0,   # prev_low\n...     9.5,   # prev_close\n...     15.0,  # prev_smoothed_plus_dm\n...     20.0,  # prev_smoothed_tr\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.plus_dm","title":"<code>plus_dm(high, low, period)</code>  <code>builtin</code>","text":"<p>Computes the Plus Directional Movement (+DM) over NumPy arrays.</p> <p>Plus Directional Movement (+DM) measures upward price movement and is used as part of the Directional Movement System developed by J. Welles Wilder.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for +DM calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the +DM values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([35266.0, 35247.5, 35235.7, 35190.8, 35182.0])\n&gt;&gt;&gt; low = np.array([35216.1, 35206.5, 35180.0, 35130.7, 35153.6])\n&gt;&gt;&gt; result = kand.plus_dm(high, low, 3)\n</code></pre>"},{"location":"api/#kand.plus_dm_inc","title":"<code>plus_dm_inc(high, prev_high, low, prev_low, prev_plus_dm, period)</code>  <code>builtin</code>","text":"<p>Calculates the next Plus DM value incrementally using previous values.</p> <p>This function enables real-time calculation of Plus DM by using the previous Plus DM value and current price data, avoiding the need to recalculate the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current high price as <code>TAFloat</code>.</p> required <code>prev_high</code> <p>Previous high price as <code>TAFloat</code>.</p> required <code>low</code> <p>Current low price as <code>TAFloat</code>.</p> required <code>prev_low</code> <p>Previous low price as <code>TAFloat</code>.</p> required <code>prev_plus_dm</code> <p>Previous Plus DM value as <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period (&gt;= 2).</p> required <p>Returns:</p> Type Description <p>The latest Plus DM value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_plus_dm = kand.plus_dm_inc(\n...     10.5,  # high\n...     10.0,  # prev_high\n...     9.8,   # low\n...     9.5,   # prev_low\n...     0.45,  # prev_plus_dm\n...     14     # period\n... )\n</code></pre>"},{"location":"api/#kand.rma","title":"<code>rma(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Running Moving Average (RMA) over a NumPy array.</p> <p>The Running Moving Average is similar to an Exponential Moving Average (EMA) but uses a different smoothing factor. It is calculated using a weighted sum of the current value and previous RMA value, with weights determined by the period size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for RMA calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the RMA values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; result = kand.rma(data, 3)\n&gt;&gt;&gt; print(result)\n[nan, nan, 2.0, 2.67, 3.44]\n</code></pre>"},{"location":"api/#kand.rma_inc","title":"<code>rma_inc(current_price, prev_rma, period)</code>  <code>builtin</code>","text":"<p>Calculates the next RMA value incrementally.</p> <p>This function provides an optimized way to calculate the latest RMA value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_rma</code> <p>The previous period's RMA value.</p> required <code>period</code> <p>The smoothing period (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>The calculated RMA value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_rma = kand.rma_inc(10.0, 9.5, 14)\n</code></pre>"},{"location":"api/#kand.roc","title":"<code>roc(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Rate of Change (ROC) over a NumPy array.</p> <p>The Rate of Change (ROC) is a momentum oscillator that measures the percentage change in price between the current price and the price n periods ago.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Number of periods to look back. Must be positive.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the ROC values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([10.0, 10.5, 11.2, 10.8, 11.5])\n&gt;&gt;&gt; result = kand.roc(data, 2)\n&gt;&gt;&gt; print(result)\n[nan, nan, 12.0, 2.86, 6.48]\n</code></pre>"},{"location":"api/#kand.roc_inc","title":"<code>roc_inc(current_price, prev_price)</code>  <code>builtin</code>","text":"<p>Calculates a single ROC value incrementally.</p> <p>This function provides an optimized way to calculate the latest ROC value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_price</code> <p>The price from n periods ago.</p> required <p>Returns:</p> Type Description <p>The calculated ROC value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; roc = kand.roc_inc(11.5, 10.0)\n&gt;&gt;&gt; print(roc)\n15.0\n</code></pre>"},{"location":"api/#kand.rocp","title":"<code>rocp(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Rate of Change Percentage (ROCP) over a NumPy array.</p> <p>The Rate of Change Percentage (ROCP) is a momentum indicator that measures the percentage change between the current price and the price n periods ago.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Number of periods to look back. Must be positive.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the ROCP values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([10.0, 10.5, 11.2, 10.8, 11.5])\n&gt;&gt;&gt; result = kand.rocp(data, 2)\n&gt;&gt;&gt; print(result)\n[nan, nan, 0.12, 0.0286, 0.0648]\n</code></pre>"},{"location":"api/#kand.rocp_inc","title":"<code>rocp_inc(current_price, prev_price)</code>  <code>builtin</code>","text":"<p>Calculates a single ROCP value incrementally.</p> <p>This function provides an optimized way to calculate the latest ROCP value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_price</code> <p>The price from n periods ago.</p> required <p>Returns:</p> Type Description <p>The calculated ROCP value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; rocp = kand.rocp_inc(11.5, 10.0)\n&gt;&gt;&gt; print(rocp)\n0.15\n</code></pre>"},{"location":"api/#kand.rocr","title":"<code>rocr(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Rate of Change Ratio (ROCR) over a NumPy array.</p> <p>The Rate of Change Ratio (ROCR) is a momentum indicator that measures the ratio between the current price and the price n periods ago.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Number of periods to look back. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the ROCR values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([10.0, 10.5, 11.2, 10.8, 11.5])\n&gt;&gt;&gt; result = kand.rocr(data, 2)\n&gt;&gt;&gt; print(result)\n[nan, nan, 1.12, 1.0286, 1.0648]\n</code></pre>"},{"location":"api/#kand.rocr100","title":"<code>rocr100(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Rate of Change Ratio * 100 (ROCR100) over a NumPy array.</p> <p>ROCR100 is a momentum indicator that measures the percentage change in price over a specified period. It compares the current price to a past price and expresses the ratio as a percentage. Values above 100 indicate price increases, while values below 100 indicate price decreases.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input price data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Number of periods to look back. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the ROCR100 values. The array has the same length as the input,</p> <p>with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([10.0, 10.5, 11.2, 10.8, 11.5])\n&gt;&gt;&gt; result = kand.rocr100(data, 2)\n&gt;&gt;&gt; print(result)\n[nan, nan, 106.67, 102.86, 106.48]\n</code></pre>"},{"location":"api/#kand.rocr100_inc","title":"<code>rocr100_inc(current_price, prev_price)</code>  <code>builtin</code>","text":"<p>Calculates a single ROCR100 value incrementally.</p> <p>This function provides an optimized way to calculate the latest ROCR100 value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_price</code> <p>The price from n periods ago.</p> required <p>Returns:</p> Type Description <p>The calculated ROCR100 value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; rocr100 = kand.rocr100_inc(11.5, 10.0)\n&gt;&gt;&gt; print(rocr100)\n115.0\n</code></pre>"},{"location":"api/#kand.rocr_inc","title":"<code>rocr_inc(current_price, prev_price)</code>  <code>builtin</code>","text":"<p>Calculates a single ROCR value incrementally.</p> <p>This function provides an optimized way to calculate the latest ROCR value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_price</code> <p>The price from n periods ago.</p> required <p>Returns:</p> Type Description <p>The calculated ROCR value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; rocr = kand.rocr_inc(11.5, 10.0)\n&gt;&gt;&gt; print(rocr)\n1.15\n</code></pre>"},{"location":"api/#kand.rsi","title":"<code>rsi(prices, period)</code>  <code>builtin</code>","text":"<p>Computes the Relative Strength Index (RSI) over NumPy arrays.</p> <p>The RSI is a momentum oscillator that measures the speed and magnitude of recent price changes to evaluate overbought or oversold conditions.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for RSI calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>RSI values</li> </ul> <ul> <li>Average gain values</li> </ul> <ul> <li>Average loss values</li> </ul> <p>Each array has the same length as the input, with the first <code>period</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([44.34, 44.09, 44.15, 43.61, 44.33, 44.83, 45.10, 45.42])\n&gt;&gt;&gt; rsi, avg_gain, avg_loss = kand.rsi(prices, 5)\n</code></pre>"},{"location":"api/#kand.rsi_inc","title":"<code>rsi_inc(current_price, prev_price, prev_avg_gain, prev_avg_loss, period)</code>  <code>builtin</code>","text":"<p>Calculates a single RSI value incrementally.</p> <p>This function provides an optimized way to calculate the latest RSI value when streaming data is available, without needing the full price history.</p> <p>Parameters:</p> Name Type Description Default <code>current_price</code> <p>The current period's price value.</p> required <code>prev_price</code> <p>The previous period's price value.</p> required <code>prev_avg_gain</code> <p>The previous period's average gain.</p> required <code>prev_avg_loss</code> <p>The previous period's average loss.</p> required <code>period</code> <p>The time period for RSI calculation.</p> required <p>Returns:</p> Type Description <p>A tuple containing (RSI value, new average gain, new average loss).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; rsi, avg_gain, avg_loss = kand.rsi_inc(45.42, 45.10, 0.24, 0.14, 14)\n</code></pre>"},{"location":"api/#kand.sar","title":"<code>sar(high, low, acceleration, maximum)</code>  <code>builtin</code>","text":"<p>Calculates the Parabolic SAR (Stop And Reverse) indicator over NumPy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>acceleration</code> <p>Initial acceleration factor (e.g. 0.02).</p> required <code>maximum</code> <p>Maximum acceleration factor (e.g. 0.2).</p> required <p>Returns:</p> Type Description <p>A tuple of four 1-D NumPy arrays containing:</p> <ul> <li>SAR values</li> </ul> <ul> <li>Trend direction (true=long, false=short)</li> </ul> <ul> <li>Acceleration factors</li> </ul> <ul> <li>Extreme points</li> </ul> <p>Each array has the same length as the input, with the first element containing NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; sar, is_long, af, ep = kand.sar(high, low, 0.02, 0.2)\n</code></pre>"},{"location":"api/#kand.sar_inc","title":"<code>sar_inc(high, low, prev_high, prev_low, prev_sar, is_long, af, ep, acceleration, maximum)</code>  <code>builtin</code>","text":"<p>Incrementally updates the Parabolic SAR with new price data.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current period's high price.</p> required <code>low</code> <p>Current period's low price.</p> required <code>prev_high</code> <p>Previous period's high price.</p> required <code>prev_low</code> <p>Previous period's low price.</p> required <code>prev_sar</code> <p>Previous period's SAR value.</p> required <code>is_long</code> <p>Current trend direction (true=long, false=short).</p> required <code>af</code> <p>Current acceleration factor.</p> required <code>ep</code> <p>Current extreme point.</p> required <code>acceleration</code> <p>Acceleration factor increment.</p> required <code>maximum</code> <p>Maximum acceleration factor.</p> required <p>Returns:</p> Type Description <p>A tuple containing (SAR value, trend direction, acceleration factor, extreme point).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; sar, is_long, af, ep = kand.sar_inc(\n...     15.0, 14.0, 14.5, 13.5, 13.0, True, 0.02, 14.5, 0.02, 0.2\n... )\n</code></pre>"},{"location":"api/#kand.sma","title":"<code>sma(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Simple Moving Average (SMA) over a NumPy array.</p> <p>The Simple Moving Average is calculated by taking the arithmetic mean of a window of values that moves across the input array. For each position, it sums the previous <code>period</code> values and divides by the period size.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for SMA calculation. Must be positive and less than input length.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the SMA values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; result = kand.sma(data, 3)\n&gt;&gt;&gt; print(result)\n[nan, nan, 2.0, 3.0, 4.0]\n</code></pre>"},{"location":"api/#kand.sma_inc","title":"<code>sma_inc(prev_sma, new_price, old_price, period)</code>  <code>builtin</code>","text":"<p>Incrementally calculates the next SMA value.</p> <p>This function provides an optimized way to update an existing SMA value when new data arrives, without recalculating the entire series.</p> <p>Parameters:</p> Name Type Description Default <code>prev_sma</code> <p>Previous SMA value.</p> required <code>new_price</code> <p>New price to include in calculation.</p> required <code>old_price</code> <p>Oldest price to remove from calculation.</p> required <code>period</code> <p>The time period for SMA calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>The next SMA value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prev_sma = 4.0\n&gt;&gt;&gt; new_price = 10.0\n&gt;&gt;&gt; old_price = 2.0\n&gt;&gt;&gt; period = 3\n&gt;&gt;&gt; next_sma = kand.sma_inc(prev_sma, new_price, old_price, period)\n&gt;&gt;&gt; print(next_sma)\n6.666666666666666\n</code></pre>"},{"location":"api/#kand.stddev","title":"<code>stddev(input, period)</code>  <code>builtin</code>","text":"<p>Calculate Standard Deviation for a NumPy array</p> <p>Standard Deviation measures the dispersion of values from their mean over a specified period. It is calculated by taking the square root of the variance.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>Input values as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Standard Deviation values</li> </ul> <ul> <li>Running sum values</li> </ul> <ul> <li>Running sum of squares values</li> </ul> <p>Each array has the same length as the input, with the first (period-1) elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; stddev, sum, sum_sq = kand.stddev(prices, 3)\n</code></pre>"},{"location":"api/#kand.stddev_inc","title":"<code>stddev_inc(price, prev_sum, prev_sum_sq, old_price, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest Standard Deviation value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>price</code> <p>Current period's price</p> required <code>prev_sum</code> <p>Previous period's sum</p> required <code>prev_sum_sq</code> <p>Previous period's sum of squares</p> required <code>old_price</code> <p>Price being removed from the period</p> required <code>period</code> <p>Period for calculation (must be &gt;= 2)</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Latest Standard Deviation value</li> </ul> <ul> <li>New sum</li> </ul> <ul> <li>New sum of squares</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; stddev, sum, sum_sq = kand.stddev_inc(\n...     10.0,   # current price\n...     100.0,  # previous sum\n...     1050.0, # previous sum of squares\n...     8.0,    # old price\n...     14      # period\n... )\n</code></pre>"},{"location":"api/#kand.stoch","title":"<code>stoch(high, low, close, k_period, k_slow_period, d_period)</code>  <code>builtin</code>","text":"<p>Computes the Stochastic Oscillator indicator over NumPy arrays.</p> <p>The Stochastic Oscillator is a momentum indicator that shows the location of the close relative to the high-low range over a set number of periods. The indicator consists of two lines: %K (the fast line) and %D (the slow line).</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>k_period</code> <p>Period for %K calculation. Must be &gt;= 2.</p> required <code>k_slow_period</code> <p>Smoothing period for slow %K. Must be &gt;= 2.</p> required <code>d_period</code> <p>Period for %D calculation. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Fast %K values</li> </ul> <ul> <li>Slow %K values</li> </ul> <ul> <li>%D values</li> </ul> <p>Each array has the same length as the input, with initial values being NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0, 12.0, 11.0])\n&gt;&gt;&gt; fast_k, k, d = kand.stoch(high, low, close, 3, 2, 2)\n</code></pre>"},{"location":"api/#kand.sum","title":"<code>sum(input, period)</code>  <code>builtin</code>","text":"<p>Calculate Sum for a NumPy array</p> <p>Calculates the rolling sum of values over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>Input values as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for sum calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing the sum values.</p> <p>The first (period-1) elements contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; sums = kand.sum(data, 3)\n</code></pre>"},{"location":"api/#kand.sum_inc","title":"<code>sum_inc(new_price, old_price, prev_sum)</code>  <code>builtin</code>","text":"<p>Calculate the latest sum value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>new_price</code> <p>The newest price value to add</p> required <code>old_price</code> <p>The oldest price value to remove</p> required <code>prev_sum</code> <p>The previous sum value</p> required <p>Returns:</p> Type Description <p>The new sum value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_sum = kand.sum_inc(\n...     5.0,    # new price\n...     3.0,    # old price\n...     10.0,   # previous sum\n... )\n</code></pre>"},{"location":"api/#kand.supertrend","title":"<code>supertrend(high, low, close, period, multiplier)</code>  <code>builtin</code>","text":"<p>Computes the Supertrend indicator over NumPy arrays.</p> <p>The Supertrend indicator is a trend-following indicator that combines Average True Range (ATR) with basic upper and lower bands to identify trend direction and potential reversal points.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for ATR calculation (typically 7-14). Must be positive.</p> required <code>multiplier</code> <p>ATR multiplier (typically 2-4).</p> required <p>Returns:</p> Type Description <p>A tuple of five 1-D NumPy arrays:</p> <ul> <li>trend: Array containing trend direction (1.0 for uptrend, -1.0 for downtrend)</li> </ul> <ul> <li>supertrend: Array containing Supertrend values</li> </ul> <ul> <li>atr: Array containing ATR values</li> </ul> <ul> <li>upper: Array containing upper band values</li> </ul> <ul> <li>lower: Array containing lower band values</li> </ul> <p>All arrays have the same length as the input, with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0, 12.0, 11.0])\n&gt;&gt;&gt; trend, supertrend, atr, upper, lower = kand.supertrend(high, low, close, 3, 3.0)\n</code></pre>"},{"location":"api/#kand.supertrend_inc","title":"<code>supertrend_inc(high, low, close, prev_close, prev_atr, prev_trend, prev_upper, prev_lower, period, multiplier)</code>  <code>builtin</code>","text":"<p>Calculates a single Supertrend value incrementally.</p> <p>This function provides an optimized way to calculate the latest Supertrend value using previous values, making it ideal for real-time calculations.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current period's high price</p> required <code>low</code> <p>Current period's low price</p> required <code>close</code> <p>Current period's close price</p> required <code>prev_close</code> <p>Previous period's close price</p> required <code>prev_atr</code> <p>Previous period's ATR value</p> required <code>prev_trend</code> <p>Previous period's trend direction (1 for uptrend, -1 for downtrend)</p> required <code>prev_upper</code> <p>Previous period's upper band</p> required <code>prev_lower</code> <p>Previous period's lower band</p> required <code>period</code> <p>ATR calculation period (typically 7-14)</p> required <code>multiplier</code> <p>ATR multiplier (typically 2-4)</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>trend: Current trend direction (1 for uptrend, -1 for downtrend)</li> </ul> <ul> <li>supertrend: Current Supertrend value</li> </ul> <ul> <li>atr: Current ATR value</li> </ul> <ul> <li>upper: Current upper band</li> </ul> <ul> <li>lower: Current lower band</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; trend, supertrend, atr, upper, lower = kand.supertrend_inc(\n...     15.0,   # Current high\n...     11.0,   # Current low\n...     14.0,   # Current close\n...     11.0,   # Previous close\n...     2.0,    # Previous ATR\n...     1,      # Previous trend\n...     16.0,   # Previous upper band\n...     10.0,   # Previous lower band\n...     7,      # ATR period\n...     3.0,    # Multiplier\n... )\n</code></pre>"},{"location":"api/#kand.t3","title":"<code>t3(data, period, vfactor)</code>  <code>builtin</code>","text":"<p>Computes the T3 (Triple Exponential Moving Average) indicator over a NumPy array.</p> <p>T3 is a sophisticated moving average developed by Tim Tillson that reduces lag while maintaining smoothness. It combines six EMAs with optimized weightings to produce a responsive yet smooth indicator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period for EMAs (must be &gt;= 2).</p> required <code>vfactor</code> <p>Volume factor controlling smoothing (typically 0-1).</p> required <p>Returns:</p> Type Description <p>A tuple of seven 1-D NumPy arrays containing:</p> <ul> <li>T3 values</li> </ul> <ul> <li>EMA1 values</li> </ul> <ul> <li>EMA2 values</li> </ul> <ul> <li>EMA3 values</li> </ul> <ul> <li>EMA4 values</li> </ul> <ul> <li>EMA5 values</li> </ul> <ul> <li>EMA6 values</li> </ul> <p>Each array has the same length as the input, with initial values being NaN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; t3, e1, e2, e3, e4, e5, e6 = kand.t3(data, 2, 0.7)\n</code></pre>"},{"location":"api/#kand.t3_inc","title":"<code>t3_inc(price, prev_ema1, prev_ema2, prev_ema3, prev_ema4, prev_ema5, prev_ema6, period, vfactor)</code>  <code>builtin</code>","text":"<p>Incrementally calculates the next T3 value.</p> <p>This function provides an optimized way to update T3 values in real-time by using previously calculated EMA values.</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <p>Latest price value to calculate T3 from.</p> required <code>prev_ema1</code> <p>Previous EMA1 value.</p> required <code>prev_ema2</code> <p>Previous EMA2 value.</p> required <code>prev_ema3</code> <p>Previous EMA3 value.</p> required <code>prev_ema4</code> <p>Previous EMA4 value.</p> required <code>prev_ema5</code> <p>Previous EMA5 value.</p> required <code>prev_ema6</code> <p>Previous EMA6 value.</p> required <code>period</code> <p>Smoothing period for EMAs (must be &gt;= 2).</p> required <code>vfactor</code> <p>Volume factor (typically 0-1).</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Latest T3 value</li> </ul> <ul> <li>Updated EMA1 value</li> </ul> <ul> <li>Updated EMA2 value</li> </ul> <ul> <li>Updated EMA3 value</li> </ul> <ul> <li>Updated EMA4 value</li> </ul> <ul> <li>Updated EMA5 value</li> </ul> <ul> <li>Updated EMA6 value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; t3, e1, e2, e3, e4, e5, e6 = kand.t3_inc(\n...     100.0,  # New price\n...     95.0,   # Previous EMA1\n...     94.0,   # Previous EMA2\n...     93.0,   # Previous EMA3\n...     92.0,   # Previous EMA4\n...     91.0,   # Previous EMA5\n...     90.0,   # Previous EMA6\n...     5,      # Period\n...     0.7,    # Volume factor\n... )\n</code></pre>"},{"location":"api/#kand.tema","title":"<code>tema(prices, period)</code>  <code>builtin</code>","text":"<p>Calculate Triple Exponential Moving Average (TEMA) for a NumPy array.</p> <p>TEMA is an enhanced moving average designed to reduce lag while maintaining smoothing properties. It applies triple exponential smoothing to put more weight on recent data and less on older data.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of 4 1-D NumPy arrays containing:</p> <ul> <li>TEMA values</li> </ul> <ul> <li>First EMA values</li> </ul> <ul> <li>Second EMA values</li> </ul> <ul> <li>Third EMA values</li> </ul> <p>The first (3 * (period - 1)) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0])\n&gt;&gt;&gt; tema, ema1, ema2, ema3 = kand.tema(prices, 3)\n</code></pre>"},{"location":"api/#kand.tema_inc","title":"<code>tema_inc(new_price, prev_ema1, prev_ema2, prev_ema3, period)</code>  <code>builtin</code>","text":"<p>Calculate the next TEMA value incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>new_price</code> <p>Latest price value to process.</p> required <code>prev_ema1</code> <p>Previous value of first EMA.</p> required <code>prev_ema2</code> <p>Previous value of second EMA.</p> required <code>prev_ema3</code> <p>Previous value of third EMA.</p> required <code>period</code> <p>Smoothing period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Current TEMA value</li> </ul> <ul> <li>Updated first EMA</li> </ul> <ul> <li>Updated second EMA</li> </ul> <ul> <li>Updated third EMA</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; tema, ema1, ema2, ema3 = kand.tema_inc(\n...     10.0,  # new_price\n...     9.0,   # prev_ema1\n...     8.0,   # prev_ema2\n...     7.0,   # prev_ema3\n...     3      # period\n... )\n</code></pre>"},{"location":"api/#kand.trange","title":"<code>trange(high, low, close)</code>  <code>builtin</code>","text":"<p>Computes the True Range (TR) over NumPy arrays.</p> <p>True Range measures the market's volatility by considering the current high-low range and the previous close price.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the TR values. The array has the same length as the input,</p> <p>with the first element containing NaN value.</p> <p>Examples:   <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0])\n&gt;&gt;&gt; result = kand.trange(high, low, close)\n&gt;&gt;&gt; print(result)\n[nan, 3.0, 4.0]\n</code></pre></p>"},{"location":"api/#kand.trange_inc","title":"<code>trange_inc(high, low, prev_close)</code>  <code>builtin</code>","text":"<p>Calculates a single True Range value for the most recent period.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current period's high price.</p> required <code>low</code> <p>Current period's low price.</p> required <code>prev_close</code> <p>Previous period's closing price.</p> required <p>Returns:</p> Type Description <p>The calculated True Range value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; tr = kand.trange_inc(12.0, 9.0, 11.0)\n&gt;&gt;&gt; print(tr)\n3.0  # max(3, 1, 2)\n</code></pre>"},{"location":"api/#kand.trima","title":"<code>trima(prices, period)</code>  <code>builtin</code>","text":"<p>Calculate Triangular Moving Average (TRIMA) for a NumPy array.</p> <p>TRIMA is a double-smoothed moving average that places more weight on the middle portion of the price series and less weight on the first and last portions. This results in a smoother moving average compared to a Simple Moving Average (SMA).</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Smoothing period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of 2 1-D NumPy arrays containing:</p> <ul> <li>First SMA values</li> </ul> <ul> <li>Final TRIMA values</li> </ul> <p>The first (period - 1) elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; sma1, trima = kand.trima(prices, 3)\n</code></pre>"},{"location":"api/#kand.trima_inc","title":"<code>trima_inc(prev_sma1, prev_sma2, new_price, old_price, old_sma1, period)</code>  <code>builtin</code>","text":"<p>Calculate the next TRIMA value incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>prev_sma1</code> <p>Previous first SMA value.</p> required <code>prev_sma2</code> <p>Previous TRIMA value.</p> required <code>new_price</code> <p>Latest price to include in calculation.</p> required <code>old_price</code> <p>Price dropping out of first window.</p> required <code>old_sma1</code> <p>SMA1 value dropping out of second window.</p> required <code>period</code> <p>Smoothing period for calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Updated first SMA value</li> </ul> <ul> <li>Updated TRIMA value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; trima, sma1 = kand.trima_inc(\n...     35.5,  # prev_sma1\n...     35.2,  # prev_sma2\n...     36.0,  # new_price\n...     35.0,  # old_price\n...     35.1,  # old_sma1\n...     5      # period\n... )\n</code></pre>"},{"location":"api/#kand.trix","title":"<code>trix(prices, period)</code>  <code>builtin</code>","text":"<p>Calculates the Triple Exponential Moving Average Oscillator (TRIX) over a NumPy array.</p> <p>TRIX is a momentum oscillator that measures the rate of change of a triple exponentially smoothed moving average. It helps identify oversold and overbought conditions and potential trend reversals through divergences.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for EMA calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of 4 1-D NumPy arrays containing:</p> <ul> <li>TRIX values</li> </ul> <ul> <li>First EMA values</li> </ul> <ul> <li>Second EMA values</li> </ul> <ul> <li>Third EMA values</li> </ul> <p>The first lookback elements of each array contain NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; trix, ema1, ema2, ema3 = kand.trix(prices, 2)\n</code></pre>"},{"location":"api/#kand.trix_inc","title":"<code>trix_inc(price, prev_ema1, prev_ema2, prev_ema3, period)</code>  <code>builtin</code>","text":"<p>Calculates a single new TRIX value incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <p>Current price value.</p> required <code>prev_ema1</code> <p>Previous first EMA value.</p> required <code>prev_ema2</code> <p>Previous second EMA value.</p> required <code>prev_ema3</code> <p>Previous third EMA value.</p> required <code>period</code> <p>Period for EMA calculations (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>TRIX value</li> </ul> <ul> <li>Updated first EMA value</li> </ul> <ul> <li>Updated second EMA value</li> </ul> <ul> <li>Updated third EMA value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; trix, ema1, ema2, ema3 = kand.trix_inc(\n...     100.0,  # price\n...     98.0,   # prev_ema1\n...     97.0,   # prev_ema2\n...     96.0,   # prev_ema3\n...     14      # period\n... )\n</code></pre>"},{"location":"api/#kand.typprice","title":"<code>typprice(high, low, close)</code>  <code>builtin</code>","text":"<p>Computes the Typical Price over NumPy arrays.</p> <p>The Typical Price is calculated by taking the arithmetic mean of the high, low and close prices for each period.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Input close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the Typical Price values. The array has the same length as the inputs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([24.20, 24.07, 24.04])\n&gt;&gt;&gt; low = np.array([23.85, 23.72, 23.64])\n&gt;&gt;&gt; close = np.array([23.89, 23.95, 23.67])\n&gt;&gt;&gt; result = kand.typprice(high, low, close)\n&gt;&gt;&gt; print(result)\n[23.98, 23.91, 23.78]\n</code></pre>"},{"location":"api/#kand.typprice_inc","title":"<code>typprice_inc(high, low, close)</code>  <code>builtin</code>","text":"<p>Calculates a single Typical Price value incrementally.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Current period's high price.</p> required <code>low</code> <p>Current period's low price.</p> required <code>close</code> <p>Current period's close price.</p> required <p>Returns:</p> Type Description <p>The calculated Typical Price value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; typ_price = kand.typprice_inc(24.20, 23.85, 23.89)\n&gt;&gt;&gt; print(typ_price)\n23.98  # (24.20 + 23.85 + 23.89) / 3\n</code></pre>"},{"location":"api/#kand.var","title":"<code>var(prices, period)</code>  <code>builtin</code>","text":"<p>Calculate Variance (VAR) for a NumPy array</p> <p>Variance measures the average squared deviation of data points from their mean over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Period for Variance calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Variance values</li> </ul> <ul> <li>Running sum values</li> </ul> <ul> <li>Running sum of squares values</li> </ul> <p>Each array has the same length as the input, with the first (period-1) elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([2.0, 4.0, 6.0, 8.0, 10.0])\n&gt;&gt;&gt; var, sum, sum_sq = kand.var(prices, 3)\n</code></pre>"},{"location":"api/#kand.var_inc","title":"<code>var_inc(price, prev_sum, prev_sum_sq, old_price, period)</code>  <code>builtin</code>","text":"<p>Calculate the latest Variance value incrementally</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <p>Python interpreter token</p> required <code>price</code> <p>Current period's price</p> required <code>prev_sum</code> <p>Previous period's sum</p> required <code>prev_sum_sq</code> <p>Previous period's sum of squares</p> required <code>old_price</code> <p>Price being removed from the period</p> required <code>period</code> <p>Period for Variance calculation (must be &gt;= 2)</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Latest Variance value</li> </ul> <ul> <li>New sum</li> </ul> <ul> <li>New sum of squares</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; var, sum, sum_sq = kand.var_inc(\n...     10.0,  # current price\n...     25.0,  # previous sum\n...     220.0, # previous sum of squares\n...     5.0,   # price to remove\n...     3      # period\n... )\n</code></pre>"},{"location":"api/#kand.vegas","title":"<code>vegas(prices)</code>  <code>builtin</code>","text":"<p>Computes the VEGAS (Volume and EMA Guided Adaptive Scaling) indicator over NumPy arrays.</p> <p>VEGAS is a trend following indicator that uses multiple EMAs to define channels and boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <p>Input prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A tuple of four 1-D NumPy arrays containing:</p> <ul> <li>Channel Upper (EMA 144)</li> </ul> <ul> <li>Channel Lower (EMA 169)</li> </ul> <ul> <li>Boundary Upper (EMA 576)</li> </ul> <ul> <li>Boundary Lower (EMA 676)</li> </ul> <p>Each array has the same length as the input, with the first 675 elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; prices = np.array([44.34, 44.09, 44.15, 43.61, 44.33])\n&gt;&gt;&gt; ch_upper, ch_lower, b_upper, b_lower = kand.vegas(prices)\n</code></pre>"},{"location":"api/#kand.vegas_inc","title":"<code>vegas_inc(price, prev_channel_upper, prev_channel_lower, prev_boundary_upper, prev_boundary_lower)</code>  <code>builtin</code>","text":"<p>Incrementally calculates the next VEGAS values.</p> <p>Parameters:</p> Name Type Description Default <code>price</code> <p>Current price value.</p> required <code>prev_channel_upper</code> <p>Previous EMA(144) value.</p> required <code>prev_channel_lower</code> <p>Previous EMA(169) value.</p> required <code>prev_boundary_upper</code> <p>Previous EMA(576) value.</p> required <code>prev_boundary_lower</code> <p>Previous EMA(676) value.</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Updated Channel Upper value</li> </ul> <ul> <li>Updated Channel Lower value</li> </ul> <ul> <li>Updated Boundary Upper value</li> </ul> <ul> <li>Updated Boundary Lower value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; price = 100.0\n&gt;&gt;&gt; prev_values = (98.0, 97.5, 96.0, 95.5)\n&gt;&gt;&gt; ch_upper, ch_lower, b_upper, b_lower = kand.vegas_inc(\n...     price,\n...     prev_values[0],\n...     prev_values[1],\n...     prev_values[2],\n...     prev_values[3]\n... )\n</code></pre>"},{"location":"api/#kand.vwap","title":"<code>vwap(high, low, close, volume)</code>  <code>builtin</code>","text":"<p>Calculates Volume Weighted Average Price (VWAP) for a series of price data.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>volume</code> <p>Volume data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>VWAP values</li> </ul> <ul> <li>Cumulative price-volume products</li> </ul> <ul> <li>Cumulative volumes</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0])\n&gt;&gt;&gt; close = np.array([9.0, 10.0, 12.0])\n&gt;&gt;&gt; volume = np.array([100.0, 150.0, 200.0])\n&gt;&gt;&gt; vwap, cum_pv, cum_vol = kand.vwap(high, low, close, volume)\n</code></pre>"},{"location":"api/#kand.vwap_inc","title":"<code>vwap_inc(high, low, close, volume, prev_cum_pv, prev_cum_vol)</code>  <code>builtin</code>","text":"<p>Calculates a single VWAP value from the latest price and volume data.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Latest high price value as <code>TAFloat</code>.</p> required <code>low</code> <p>Latest low price value as <code>TAFloat</code>.</p> required <code>close</code> <p>Latest close price value as <code>TAFloat</code>.</p> required <code>volume</code> <p>Latest volume value as <code>TAFloat</code>.</p> required <code>prev_cum_pv</code> <p>Previous cumulative price-volume product as <code>TAFloat</code>.</p> required <code>prev_cum_vol</code> <p>Previous cumulative volume as <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A tuple containing (new cumulative PV, new cumulative volume, new VWAP).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; new_cum_pv, new_cum_vol, vwap = kand.vwap_inc(15.0, 11.0, 14.0, 200.0, 1000.0, 150.0)\n</code></pre>"},{"location":"api/#kand.wclprice","title":"<code>wclprice(high, low, close)</code>  <code>builtin</code>","text":"<p>Calculates the Weighted Close Price (WCLPRICE) for a series of price data.</p> <p>The Weighted Close Price is a price indicator that assigns more weight to the closing price compared to high and low prices. It provides a single value that reflects price action with emphasis on the closing price.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>High prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Close prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>A 1-D NumPy array containing the WCLPRICE values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0])\n&gt;&gt;&gt; wclprice = kand.wclprice(high, low, close)\n</code></pre>"},{"location":"api/#kand.wclprice_inc","title":"<code>wclprice_inc(high, low, close)</code>  <code>builtin</code>","text":"<p>Calculates a single Weighted Close Price (WCLPRICE) value from the latest price data.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Latest high price value as <code>TAFloat</code>.</p> required <code>low</code> <p>Latest low price value as <code>TAFloat</code>.</p> required <code>close</code> <p>Latest close price value as <code>TAFloat</code>.</p> required <p>Returns:</p> Type Description <p>The calculated WCLPRICE value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; wclprice = kand.wclprice_inc(15.0, 11.0, 14.0)\n</code></pre>"},{"location":"api/#kand.willr","title":"<code>willr(high, low, close, period)</code>  <code>builtin</code>","text":"<p>Calculates Williams %R (Williams Percent Range) for a series of prices.</p> <p>Williams %R is a momentum indicator that measures overbought and oversold levels by comparing the closing price to the high-low range over a specified period. The indicator oscillates between 0 and -100.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <p>Input high prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>low</code> <p>Input low prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>close</code> <p>Input closing prices as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Lookback period for calculations. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A tuple of three 1-D NumPy arrays containing:</p> <ul> <li>Williams %R values</li> </ul> <ul> <li>Highest high values for each period</li> </ul> <ul> <li>Lowest low values for each period</li> </ul> <p>Each array has the same length as the input, with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; high = np.array([10.0, 12.0, 15.0, 14.0, 13.0])\n&gt;&gt;&gt; low = np.array([8.0, 9.0, 11.0, 10.0, 9.0])\n&gt;&gt;&gt; close = np.array([9.0, 11.0, 14.0, 12.0, 11.0])\n&gt;&gt;&gt; willr, highest, lowest = kand.willr(high, low, close, 3)\n</code></pre>"},{"location":"api/#kand.willr_inc","title":"<code>willr_inc(prev_highest_high, prev_lowest_low, prev_high, prev_low, close, high, low)</code>  <code>builtin</code>","text":"<p>Incrementally calculates Williams %R for the latest data point.</p> <p>This function provides an optimized way to calculate the latest Williams %R value by using previously calculated highest high and lowest low values.</p> <p>Parameters:</p> Name Type Description Default <code>prev_highest_high</code> <p>Previous period's highest high value.</p> required <code>prev_lowest_low</code> <p>Previous period's lowest low value.</p> required <code>prev_high</code> <p>Previous period's high price.</p> required <code>prev_low</code> <p>Previous period's low price.</p> required <code>close</code> <p>Current period's closing price.</p> required <code>high</code> <p>Current period's high price.</p> required <code>low</code> <p>Current period's low price.</p> required <p>Returns:</p> Type Description <p>A tuple containing:</p> <ul> <li>Current Williams %R value</li> </ul> <ul> <li>New highest high</li> </ul> <ul> <li>New lowest low</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; willr, high, low = kand.willr_inc(15.0, 10.0, 14.0, 11.0, 12.0, 13.0, 11.0)\n</code></pre>"},{"location":"api/#kand.wma","title":"<code>wma(data, period)</code>  <code>builtin</code>","text":"<p>Computes the Weighted Moving Average (WMA) over a NumPy array.</p> <p>The Weighted Moving Average assigns linearly decreasing weights to each price in the period, giving more importance to recent prices and less to older ones.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <p>Input data as a 1-D NumPy array of type <code>TAFloat</code>.</p> required <code>period</code> <p>Window size for WMA calculation. Must be &gt;= 2.</p> required <p>Returns:</p> Type Description <p>A new 1-D NumPy array containing the WMA values. The array has the same length as the input,</p> <p>with the first <code>period-1</code> elements containing NaN values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import kand\n&gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n&gt;&gt;&gt; result = kand.wma(data, 3)\n&gt;&gt;&gt; print(result)\n[nan, nan, 2.0, 3.0, 4.0]\n</code></pre>"},{"location":"api/#kand.wma_inc","title":"<code>wma_inc(input_window, period)</code>  <code>builtin</code>","text":"<p>Incrementally calculates the next WMA value.</p> <p>This function provides an optimized way to calculate the latest WMA value by using a window of the most recent prices.</p> <p>Parameters:</p> Name Type Description Default <code>input_window</code> <p>Array of price values ordered from newest to oldest.</p> required <code>period</code> <p>The time period for WMA calculation (must be &gt;= 2).</p> required <p>Returns:</p> Type Description <p>The next WMA value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kand\n&gt;&gt;&gt; window = [5.0, 4.0, 3.0]  # newest to oldest\n&gt;&gt;&gt; wma = kand.wma_inc(window, 3)\n&gt;&gt;&gt; print(wma)\n4.333333333333333\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>This document records all significant updates and changes to the Kand project.</p>"},{"location":"changelog/#unreleased","title":"[unreleased]","text":""},{"location":"changelog/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(ci) Fix publish-rust</li> <li>(.editorconfig) Fix path</li> </ul>"},{"location":"changelog/#022-2025-03-04","title":"[0.2.2] - 2025-03-04","text":""},{"location":"changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>(precision) Add f32 floating-point precision support (#10)</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(tema) Resolve ambiguous numeric type errors in TEMA calculation</li> <li>(tema) Resolve ambiguous numeric type errors in TEMA calculation</li> <li>(willr) Resolve Clippy warnings for strict float comparisons</li> <li>(stats) Resolve Clippy warnings for strict float comparisons in max/min</li> <li>(ci) Fix test-rust</li> </ul>"},{"location":"changelog/#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Use _inc instead of _incremental</li> </ul>"},{"location":"changelog/#021-2025-03-02","title":"[0.2.1] - 2025-03-02","text":""},{"location":"changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>(precision) Add f32 floating-point precision support</li> </ul>"},{"location":"changelog/#020-2025-03-02","title":"[0.2.0] - 2025-03-02","text":""},{"location":"changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li>[breaking] Release v0.2.0 with major type system refactoring</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(ci:publish-doc) Update publish-doc</li> <li>(makefile) Fix uv-sync, add params for gen_stub.py</li> </ul>"},{"location":"changelog/#other","title":"\ud83d\udcbc Other","text":"<ul> <li>Update the types and lib type</li> </ul>"},{"location":"changelog/#013-2025-02-27","title":"[0.1.3] - 2025-02-27","text":""},{"location":"changelog/#refactor_1","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(ci:release) Refactor release ci</li> </ul>"},{"location":"changelog/#012-2025-02-27","title":"[0.1.2] - 2025-02-27","text":""},{"location":"changelog/#bug-fixes_3","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(makefile) Update makefile</li> <li>(bench) Added #[allow(clippy::expect_used)] to suppress clippy warnings</li> <li>(cdl_gravestone_doji) Optimize T::from(100).unwrap() to T::from(100).ok_or(KandError::ConversionError)?</li> <li>(var) Replace unwrap with safe conversion using ok_or(KandError::ConversionError)?</li> </ul>"},{"location":"changelog/#refactor_2","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(ci) Simplify release workflow and customize changelog footer</li> <li>(tpo) Replace as f64 with f64::from(u8::try_from(i).unwrap()) for type conversion</li> </ul>"},{"location":"changelog/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Update rust doc</li> <li>(helper) Add missing error documentation for lowest_bars and highest_bars functions</li> </ul>"},{"location":"changelog/#011-2025-02-27","title":"[0.1.1] - 2025-02-27","text":""},{"location":"changelog/#features_3","title":"\ud83d\ude80 Features","text":"<ul> <li>(ci) Add changelog ci.</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(aroonosc) Optimize precision conversion by replacing 'as' with 'T::from' for safety</li> </ul> <p>\"Quantitative trading begins with data, thrives on strategy, and succeeds through execution. Kand, making trading simpler.\"</p>"},{"location":"install/","title":"Installation Guide","text":"<p>Get started with <code>kand</code> through Python or Docker. This guide covers all installation methods and system compatibility details.</p>"},{"location":"install/#python-installation","title":"Python Installation","text":""},{"location":"install/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li><code>pip</code> (Python package installer)</li> </ul>"},{"location":"install/#install-from-pypi","title":"Install from PyPI","text":"<p>Install <code>kand</code> with one command\u2014precompiled wheels available for instant setup:</p> <pre><code>pip install kand\n</code></pre> <p>Supported Platforms &amp; Python Versions</p> <p>We provide precompiled packages on PyPI for major systems and Python versions:</p> Platform Supported Python Versions Linux 3.8, 3.9, 3.10, 3.11, 3.12 musl Linux 3.8, 3.9, 3.10, 3.11, 3.12 Windows 3.8, 3.9, 3.10, 3.11, 3.12, 3.13 macOS 3.8, 3.9, 3.10, 3.11, 3.12, 3.13 <p>No compilation needed\u2014just <code>pip install</code> and go!</p>"},{"location":"install/#docker-usage","title":"Docker Usage","text":""},{"location":"install/#pull-the-official-image","title":"Pull the Official Image","text":"<p>Grab the latest <code>kand</code> container:</p> <pre><code>docker pull ghcr.io/rust-ta/kand:latest\n</code></pre>"},{"location":"install/#run-with-docker","title":"Run with Docker","text":"<p>Launch it interactively:</p> <pre><code>docker run -it --rm ghcr.io/rust-ta/kand:latest\n</code></pre> <p>Or build your own:</p> <pre><code>docker build -t my-kand-app .\ndocker run -it --rm my-kand-app\n</code></pre>"},{"location":"install/#troubleshooting","title":"Troubleshooting","text":"<p>Encounter issues? Try these steps:</p> <ol> <li>Update <code>pip</code> or <code>cargo</code> to the latest version.</li> <li>Verify Python (3.8+) or Rust (1.80+) compatibility.</li> <li>Ensure the Docker daemon is running.</li> <li>Check GitHub Issues for solutions.</li> </ol> <p>Note</p> <p>Still stuck? Join our community or file an issue on GitHub!</p>"},{"location":"install/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Documentation to dive into <code>kand</code>.</li> <li>Join our community for help and updates.</li> <li>Report bugs or suggestions on GitHub.</li> </ul>"},{"location":"performance/","title":"Performance Testing","text":""},{"location":"performance/#introduction","title":"Introduction","text":"<p>This document showcases the performance testing results for Exponential Moving Average (EMA) computations, comparing single-threaded and multi-threaded approaches. Tests were conducted on two platforms: a Windows laptop featuring an Intel Core i7-13700 processor and a Mac Mini powered by an Apple M4 chip. The analysis highlights how thread count impacts computational efficiency across diverse dataset sizes, with a special focus on the superior scalability of <code>kand</code> over <code>talib</code>.</p> <p>Info</p> <p><code>kand</code> vs. <code>talib</code>: While <code>talib</code> is constrained to single-threaded execution, <code>kand</code> leverages multi-threading to unlock significant performance gains, especially on modern multi-core hardware.</p>"},{"location":"performance/#test-environment","title":"Test Environment","text":"<p>Hardware Specifications</p> Windows PlatformMac Platform <ul> <li>Device: Laptop</li> <li>CPU: Intel Core i7-13700<ul> <li>6 Performance cores</li> </ul> </li> <li>OS: Windows 11 Pro</li> </ul> <ul> <li>Device: Mac Mini</li> <li>CPU: Apple M4<ul> <li>4 Performance cores</li> </ul> </li> <li>OS: macOS Sonoma</li> </ul> <p>Software Stack</p> Component Version Description :snake: Python 3.11 Core runtime environment :chart_with_upwards_trend: TA-Lib 0.6.3 Technical analysis baseline :zap: Kand 0.0.11 High-performance implementation <p>Version Compatibility</p> <p>All tests were conducted using the latest stable releases of each component. Performance characteristics may vary with different versions.</p>"},{"location":"performance/#test-methodology","title":"Test Methodology","text":"<p>Test Code Location</p> <p>All benchmark code is available in the <code>python/benches</code> directory: - <code>bench_ema.py</code>: Single-thread performance testing - <code>bench_ema_mt.py</code>: Multi-thread performance testing</p> <p>System Variability</p> <p>Performance results may vary significantly across different systems due to: - CPU architecture and clock speeds - Memory configuration and speed - Operating system scheduling - System load and background processes - Thermal conditions</p> <p>We strongly recommend running the benchmarks on your specific system for the most accurate performance assessment.</p> <ul> <li>Single-threaded tests: Executed using 1 thread with <code>talib.EMA</code>.</li> <li>Multi-threaded tests: Conducted with <code>kand.ema</code>:</li> <li>Windows i7-13700: 2, 4, and 6 threads.</li> <li>Mac Mini M4: 2 and 4 threads.</li> <li>Dataset sizes: 50K, 100K, 250K, 500K, 1M, 2.5M, 5M, 10M data points.</li> <li>EMA period: 30.</li> <li>Runs per test: 1000 iterations to calculate average execution time.</li> <li>Tools: Python scripts leveraging <code>talib.EMA</code> (single-threaded) and <code>kand.ema</code> (multi-threaded).</li> </ul>"},{"location":"performance/#results","title":"Results","text":""},{"location":"performance/#windows-i7-13700-mobile","title":"Windows i7-13700 Mobile","text":"Single-threaded2 Threads4 Threads6 Threads <p> Figure 1: EMA computation performance on Windows with 1 thread using <code>talib</code>.</p> <p> Figure 2: Performance with 2 threads using <code>kand</code>.</p> <p> Figure 3: Performance with 4 threads using <code>kand</code>.</p> <p> Figure 4: Performance with 6 threads using <code>kand</code>.</p>"},{"location":"performance/#mac-mini-m4","title":"Mac Mini M4","text":"Single-threaded2 Threads4 Threads <p> Figure 5: EMA computation performance on Mac Mini with 1 thread using <code>talib</code>.</p> <p> Figure 6: Performance with 2 threads using <code>kand</code>.</p> <p> Figure 7: Performance with 4 threads using <code>kand</code>.</p>"},{"location":"performance/#analysis","title":"Analysis","text":"<p>The results reveal compelling insights into performance trends:</p> <ul> <li> <p>Multi-threading Advantage with <code>kand</code>: Unlike <code>talib</code>, which is bottlenecked by single-threaded execution, <code>kand</code> harnesses multiple threads to drastically reduce EMA computation times. This advantage becomes increasingly evident with larger datasets (e.g., 5M and 10M points).</p> </li> <li> <p>Scalability:</p> </li> <li> <p>On the Windows i7-13700, performance peaks at 6 threads, fully utilizing its 6 P-cores.</p> </li> <li>On the Mac Mini M4, efficiency maxes out at 4 threads, aligned with its 4 P-cores.</li> </ul> <p>Why <code>kand</code> Outshines <code>talib</code></p> <p>The single-threaded nature of <code>talib</code> limits its ability to exploit modern multi-core CPUs. In contrast, <code>kand</code>\u2019s multi-threaded design scales seamlessly with core count, delivering superior performance on datasets of any size.</p> <p>Key Takeaway</p> <p>By embracing multi-threading, <code>kand</code> unlocks the full potential of modern processors, leaving <code>talib</code>\u2019s single-threaded approach in the dust\u2014especially for high-performance financial computations.</p> <p>Key Takeaway</p> <p>\ud83d\udccc Thread counts are capped by the number of performance cores (P-cores). The i7-13700 supports up to 6 threads with its 6 P-cores, while the M4 is limited to 4 threads due to its 4 P-cores.</p>"},{"location":"performance/#conclusion","title":"Conclusion","text":"<p>Multi-threading capabilities in <code>kand</code> deliver exceptional performance gains across various technical analysis computations, consistently outperforming the single-threaded limitations of traditional libraries like <code>talib</code>. Our benchmarks on the Windows i7-13700 (6 P-cores) and Mac Mini M4 (4 P-cores) demonstrate impressive scalability, with the i7-13700 achieving superior throughput at higher thread counts. For applications dealing with large-scale financial data processing, <code>kand</code>'s sophisticated multi-core utilization architecture provides a significant competitive advantage. This foundation sets the stage for future optimizations across different hardware configurations and computational scenarios, making <code>kand</code> an ideal choice for high-performance financial analysis systems.</p>"}]}